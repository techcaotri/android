
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Android PMS - Android 6 PMS analysis article 1 Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="@gitbook-ng/gitbook 3.3.6">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fancybox/jquery.fancybox.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fancybox/jquery.fancybox-buttons.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-anchor-navigation-ex-toc/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-ace/ace.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search-plus/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-interactive/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-wide-page/wide.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="styles/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="Android PMS - Android 6 PMS analysis article 2.html" />
    
    
    <link rel="prev" href="Android PMS - Android 6 PMS Analysis.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    Graphical Android
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="Graphical Android - Zygote, System Server startup analysis.html">
            
                <a href="Graphical Android - Zygote, System Server startup analysis.html">
            
                    
                    Graphical Android - Zygote, System Server startup analysis
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    Android Permissions
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="Android Permissions - Android Runtime Permission.html">
            
                <a href="Android Permissions - Android Runtime Permission.html">
            
                    
                    Android Permissions - Android Runtime Permission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="Android Permissions - Android grantRuntimePermission Detailed.html">
            
                <a href="Android Permissions - Android grantRuntimePermission Detailed.html">
            
                    
                    Android Permissions - Android grantRuntimePermission Detailed
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="Android Permissions - Android GrantPermissionsActivity Detailed.html">
            
                <a href="Android Permissions - Android GrantPermissionsActivity Detailed.html">
            
                    
                    Android Permissions - Android GrantPermissionsActivity Detailed
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="Android Permissions - AppOps control for Normal permission.html">
            
                <a href="Android Permissions - AppOps control for Normal permission.html">
            
                    
                    Android Permissions - AppOps control for Normal permission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="Android Permissions - Android native permission control process.html">
            
                <a href="Android Permissions - Android native permission control process.html">
            
                    
                    Android Permissions - Android native permission control process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="Android Permissions - The difference between setUidMode and setMode in AppOps.html">
            
                <a href="Android Permissions - The difference between setUidMode and setMode in AppOps.html">
            
                    
                    Android Permissions - The difference between setUidMode and setMode in AppOps
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="Android Permissions - Application permissions before android M and application permissions after M.html">
            
                <a href="Android Permissions - Application permissions before android M and application permissions after M.html">
            
                    
                    Android Permissions - Application permissions before android M and application permissions after M
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="Android Permissions - Provider permissions detailed.html">
            
                <a href="Android Permissions - Provider permissions detailed.html">
            
                    
                    Android Permissions - Provider permissions detailed
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    Android OTA
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="Android OTA - Android OTA upgrade principle and process analysis 1.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 1.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="Android OTA - Android OTA upgrade principle and process analysis 2.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 2.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="Android OTA - Android OTA upgrade principle and process analysis 3.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 3.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="Android OTA - Android OTA upgrade principle and process analysis 4.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 4.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 4
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="Android OTA - Android OTA upgrade principle and process analysis 5.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 5.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="Android OTA - Android OTA upgrade principle and process analysis 6.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 6.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.7" data-path="Android OTA - Android OTA upgrade principle and process analysis 7.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 7.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 7
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.8" data-path="Android OTA - Android OTA upgrade principle and process analysis 8.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 8.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 8
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.9" data-path="Android OTA - Android OTA upgrade principle and process analysis 9.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 9.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 9
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" >
            
                <span>
            
                    
                    Android Package Manager Service (PMS)
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="Android PMS - Explore the Android PMS service.html">
            
                <a href="Android PMS - Explore the Android PMS service.html">
            
                    
                    Android PMS - Explore the Android PMS service
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="Android PMS - Some rules of the PMS runtime.html">
            
                <a href="Android PMS - Some rules of the PMS runtime.html">
            
                    
                    Android PMS - Some rules of the PMS runtime
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="Android PMS - Android 6 PMS Analysis.html">
            
                <a href="Android PMS - Android 6 PMS Analysis.html">
            
                    
                    Android PMS - Android 6 PMS Analysis
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.5.4" data-path="Android PMS - Android 6 PMS analysis article 1.html">
            
                <a href="Android PMS - Android 6 PMS analysis article 1.html">
            
                    
                    Android PMS - Android 6 PMS analysis article 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="Android PMS - Android 6 PMS analysis article 2.html">
            
                <a href="Android PMS - Android 6 PMS analysis article 2.html">
            
                    
                    Android PMS - Android 6 PMS analysis article 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.6" data-path="Android PMS - Android 6 PMS analysis of the next article.html">
            
                <a href="Android PMS - Android 6 PMS analysis of the next article.html">
            
                    
                    Android PMS - Android 6 PMS analysis of the next article
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.7" data-path="Android PMS - Android 6 PMS install APK prelude.html">
            
                <a href="Android PMS - Android 6 PMS install APK prelude.html">
            
                    
                    Android PMS - Android 6 PMS install APK prelude
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.8" data-path="Android PMS - Android 6 PMS installation APK.html">
            
                <a href="Android PMS - Android 6 PMS installation APK.html">
            
                    
                    Android PMS - Android 6 PMS installation APK
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.9" data-path="Android PMS - Android 6 PMS installation APK next article.html">
            
                <a href="Android PMS - Android 6 PMS installation APK next article.html">
            
                    
                    Android PMS - Android 6 PMS installation APK next article
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.10" data-path="Android PMS - Android 6 PMS Uninstall APK.html">
            
                <a href="Android PMS - Android 6 PMS Uninstall APK.html">
            
                    
                    Android PMS - Android 6 PMS Uninstall APK
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.11" data-path="Android PMS - Android 6 PMS daemon installd.html">
            
                <a href="Android PMS - Android 6 PMS daemon installd.html">
            
                    
                    Android PMS - Android 6 PMS daemon installd
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" >
            
                <span>
            
                    
                    Android AOSP
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="Android AOSP - Debugging AOSP Platform code with Android Studio - Java Debugger.html">
            
                <a href="Android AOSP - Debugging AOSP Platform code with Android Studio - Java Debugger.html">
            
                    
                    Android AOSP - Debugging AOSP Platform code with Android Studio - Java Debugger
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="Android AOSP - Modify applications and rebuild emulator image effectively.html">
            
                <a href="Android AOSP - Modify applications and rebuild emulator image effectively.html">
            
                    
                    Android AOSP - Modify applications and rebuild emulator image effectively
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" >
            
                <span>
            
                    
                    Android General
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="Android General - Reliable connection to AIDL IPC Service in Android.html">
            
                <a href="Android General - Reliable connection to AIDL IPC Service in Android.html">
            
                    
                    Android General - Reliable connection to AIDL IPC Service in Android
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" >
            
                <span>
            
                    
                    Android Binder
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" >
            
                <span>
            
                    
                    Android Activity Manager Service (AMS)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" >
            
                <span>
            
                    
                    Live555
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="Live555 - Live555 source code analysis_introduction.html">
            
                <a href="Live555 - Live555 source code analysis_introduction.html">
            
                    
                    Live555 - Live555 source code analysis_introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="Live555 - Live555 source code analysis_infrastructure.html">
            
                <a href="Live555 - Live555 source code analysis_infrastructure.html">
            
                    
                    Live555 - Live555 source code analysis_infrastructure
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="Live555 - Live555 source code analysis_mediaserver.html">
            
                <a href="Live555 - Live555 source code analysis_mediaserver.html">
            
                    
                    Live555 - Live555 source code analysis_mediaserver
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="Live555 - Wireshark capture packet analysis RTSP_RTP_RTCP basic working process.html">
            
                <a href="Live555 - Wireshark capture packet analysis RTSP_RTP_RTCP basic working process.html">
            
                    
                    Live555 - Wireshark capture packet analysis RTSP_RTP_RTCP basic working process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="Live555 - Live555 source code analysis_rtspserver.html">
            
                <a href="Live555 - Live555 source code analysis_rtspserver.html">
            
                    
                    Live555 - Live555 source code analysis_rtspserver
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.6" data-path="Live555 - Live555 source code analysis_describe processing.html">
            
                <a href="Live555 - Live555 source code analysis_describe processing.html">
            
                    
                    Live555 - Live555 source code analysis_describe processing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.7" data-path="Live555 - Live555 source code analysis_setup processing.html">
            
                <a href="Live555 - Live555 source code analysis_setup processing.html">
            
                    
                    Live555 - Live555 source code analysis_setup processing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.8" data-path="Live555 - Live555 source code analysis_play processing.html">
            
                <a href="Live555 - Live555 source code analysis_play processing.html">
            
                    
                    Live555 - Live555 source code analysis_play processing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.9" data-path="Live555 - Live555 source code analysis_RTSPServer component structure.html">
            
                <a href="Live555 - Live555 source code analysis_RTSPServer component structure.html">
            
                    
                    Live555 - Live555 source code analysis_RTSPServer component structure
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.10" data-path="Live555 - Live555 source code analysis_servermediasession.html">
            
                <a href="Live555 - Live555 source code analysis_servermediasession.html">
            
                    
                    Live555 - Live555 source code analysis_servermediasession
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.11" data-path="Live555 - Live555 source code analysis_subsession SDP line generation.html">
            
                <a href="Live555 - Live555 source code analysis_subsession SDP line generation.html">
            
                    
                    Live555 - Live555 source code analysis_subsession SDP line generation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.12" data-path="Live555 - Live555 source code analysis_Subsession SETUP.html">
            
                <a href="Live555 - Live555 source code analysis_Subsession SETUP.html">
            
                    
                    Live555 - Live555 source code analysis_Subsession SETUP
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.13" data-path="Live555 - Live555 source code analysis_play start.html">
            
                <a href="Live555 - Live555 source code analysis_play start.html">
            
                    
                    Live555 - Live555 source code analysis_play start
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11" >
            
                <span>
            
                    
                    Flutter
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="Flutter Framework Analysis 1 - Overview and Window.html">
            
                <a href="Flutter Framework Analysis 1 - Overview and Window.html">
            
                    
                    Flutter Framework Analysis 1 - Overview and Window
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="Flutter Framework Analysis 2 - Initialization.html">
            
                <a href="Flutter Framework Analysis 2 - Initialization.html">
            
                    
                    Flutter Framework Analysis 2 - Initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="Flutter Framework Analysis 3 - Widget, Element and RenderObject.html">
            
                <a href="Flutter Framework Analysis 3 - Widget, Element and RenderObject.html">
            
                    
                    Flutter Framework Analysis 3 - Widget, Element and RenderObject
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.4" data-path="Flutter Framework Analysis 4 - Flutter Framework Operation.html">
            
                <a href="Flutter Framework Analysis 4 - Flutter Framework Operation.html">
            
                    
                    Flutter Framework Analysis 4 - Flutter Framework Operation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.5" data-path="Flutter Framework Analysis 5 - Animation.html">
            
                <a href="Flutter Framework Analysis 5 - Animation.html">
            
                    
                    Flutter Framework Analysis 5 - Animation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.6" data-path="Flutter Framework Analysis 6 - Layout.html">
            
                <a href="Flutter Framework Analysis 6 - Layout.html">
            
                    
                    Flutter Framework Analysis 6 - Layout
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.7" data-path="Flutter Framework Analysis 7 - Drawing.html">
            
                <a href="Flutter Framework Analysis 7 - Drawing.html">
            
                    
                    Flutter Framework Analysis 7 - Drawing
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Android PMS - Android 6 PMS analysis article 1</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div class="search-plus" id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <div id="anchor-navigation-ex-navbar"><i class="fa fa-anchor"></i><ul><li><span class="title-icon "></span><a href="#android-6-pms-analysis-article-1"><b>1. </b>Android 6 PMS analysis article 1</a></li></ul></div><a href="#android-6-pms-analysis-article-1" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><h1 id="android-6-pms-analysis-article-1"><a name="android-6-pms-analysis-article-1" class="anchor-navigation-ex-anchor" href="#android-6-pms-analysis-article-1"><i class="fa fa-link" aria-hidden="true"></i></a>1. Android 6 PMS analysis article 1</h1>
<ul>
<li><p><a href="http://www.iloveandroid.net/tags/Android%E6%A0%B8%E5%BF%83%E6%9C%8D%E5%8A%A1/" target="_blank">Android core service</a></p>
</li>
<li><p><a href="http://www.iloveandroid.net/categories/Android%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/" target="_blank">Android underlying development</a></p>
</li>
</ul>
<p>This article focuses on PMS scanning and parsing APK files.</p>
<p>Continue to analyze the construction method of the PMS.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">mHandlerThread = new ServiceThread(TAG,
Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/);
mHandlerThread.start();
mHandler = new PackageHandler(mHandlerThread.getLooper());
Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);

File dataDir = Environment.getDataDirectory();
mAppDataDir = new File(dataDir, &quot;data&quot;);
mAppInstallDir = new File(dataDir, &quot;app&quot;);
mAppLib32InstallDir = new File(dataDir, &quot;app-lib&quot;);
mAsecInternalPath = new File(dataDir, &quot;app-asec&quot;).getPath();
mUserAppDataDir = new File(dataDir, &quot;user&quot;);
mDrmAppPrivateInstallDir = new File(dataDir, &quot;app-private&quot;);

sUserManager = new UserManagerService(context, this,
mInstallLock, mPackages);<br></div></div>

<p>Create a PackageHandler object and create a message loop for the PackageHandler
to handle the installation request for the apk.</p>
<p>Generate file objects for subdirectories under the &quot;/data&quot; directory:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;sh&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">/data/data
/data/app
/data/app-lib
/data/user
/data/app-private<br></div></div>

<p>Create a user management service UserManagerService:</p>
<p>Continue the PMS construction method:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">// Propagate permission configuration in to package manager.
    ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig
            = systemConfig.getPermissions();
    for (int i=0; i&lt;permConfig.size(); i++) {
        SystemConfig.PermissionEntry perm = permConfig.valueAt(i);
        BasePermission bp = mSettings.mPermissions.get(perm.name);
        if (bp == null) {
            bp = new BasePermission(perm.name, &quot;android&quot;, BasePermission.TYPE_BUILTIN);
            mSettings.mPermissions.put(perm.name, bp);
        }
        if (perm.gids != null) {
            bp.setGids(perm.gids, perm.perUser);
        }
    }

    ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries();
    for (int i=0; i&lt;libConfig.size(); i++) {
        mSharedLibraries.put(libConfig.keyAt(i),
                new SharedLibraryEntry(libConfig.valueAt(i), null));
    }

    mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();<br></div></div>

<p>The role is to put the name of the permission read from /system/etc/permission
and the corresponding gid into bp, and then save it in the mPermissions of
mSettings.</p>
<p>Also put the shared library read from /system/etc/permission into the PMS
variable mSharedLibraries.</p>
<p>carry on</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">mRestoredSettings = mSettings.readLPw(this, sUserManager.getUsers(false),
        mSdkVersion, mOnlyCore);

String customResolverActivity = Resources.getSystem().getString(
        R.string.config_customResolverActivity);
if (TextUtils.isEmpty(customResolverActivity)) {
    customResolverActivity = null;
} else {
    mCustomResolverComponentName = ComponentName.unflattenFromString(
            customResolverActivity);
}<br></div></div>

<p>Here we first call the ReadLPw function of Settings to parse the installation
list information saved in packages.xml and packages-backup.xml, and add the
parsed pakcages information to the corresponding data structure.</p>
<p>Here we assume that this is the first time the Android device is powered on. All
the packages.xml and packages-backup.xml files do not exist yet. So the Settings
readLPw function will return directly.</p>
<p>carry on:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">long startTime = SystemClock.uptimeMillis(); // Get current time

EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,
       startTime);

// Set flag to monitor and not change apk file paths when
// scanning install directories.
final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;//&#x8BBE;&#x7F6E;&#x626B;&#x63CF;&#x6A21;&#x5F0F;

final ArraySet&lt;String&gt; alreadyDexOpted = new ArraySet&lt;String&gt;();// Store optimized files

/**
* Add everything in the in the boot class path to the
* list of process files because dexopt will have been run
* if necessary during zygote startup.
*/
final String bootClassPath = System.getenv(&quot;BOOTCLASSPATH&quot;);// Get the value of the BOOTCLASSPATH environment variable
final String systemServerClassPath = System.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);//Get the value of the SYSTEMSERVERCLASSPATH environment variable

if (bootClassPath != null) {
   String[] bootClassPathElements = splitString(bootClassPath, &apos;:&apos;);
   for (String element : bootClassPathElements) {
       alreadyDexOpted.add(element); //Add the specified file in the BOOTCLASSPATH to the list of optimized files.
   }
} else {
   Slog.w(TAG, &quot;No BOOTCLASSPATH found!&quot;);
}

if (systemServerClassPath != null) {
   String[] systemServerClassPathElements = splitString(systemServerClassPath, &apos;:&apos;);
   for (String element : systemServerClassPathElements) {
       alreadyDexOpted.add(element);//Add files from SYSTEMSERVERCLASSPATH to the list of optimized files
   }
} else {
   Slog.w(TAG, &quot;No SYSTEMSERVERCLASSPATH found!&quot;);
}<br></div></div>

<p>This code mainly adds the files in BOOTCLASSPATH and SYSTEMSERVERCLASSPATH to
the readyDexOpted HashSet, because they have been optimized for Dex when zygote
is started.</p>
<p>carry on</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">final List&lt;String&gt; allInstructionSets = InstructionSets.getAllInstructionSets();
final String[] dexCodeInstructionSets =
        getDexCodeInstructionSets(
                allInstructionSets.toArray(new String[allInstructionSets.size()]));

/**
 * Ensure all external libraries have had dexopt run on them.
 */
if (mSharedLibraries.size() &gt; 0) {
    // NOTE: For now, we&apos;re compiling these system &quot;shared libraries&quot;
    // (and framework jars) into all available architectures. It&apos;s possible
    // to compile them only when we come across an app that uses them (there&apos;s
    // already logic for that in scanPackageLI) but that adds some complexity.
    for (String dexCodeInstructionSet : dexCodeInstructionSets) {
        for (SharedLibraryEntry libEntry : mSharedLibraries.values()) {
            final String lib = libEntry.path;
            if (lib == null) {
                continue;
            }

            try {
                int dexoptNeeded = DexFile.getDexOptNeeded(lib, null, dexCodeInstructionSet, false);
                if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
                    alreadyDexOpted.add(lib);
                    mInstaller.dexopt(lib, Process.SYSTEM_UID, true, dexCodeInstructionSet, dexoptNeeded);
                }
            } catch (FileNotFoundException e) {
                Slog.w(TAG, &quot;Library not found: &quot; + lib);
            } catch (IOException e) {
                Slog.w(TAG, &quot;Cannot dexopt &quot; + lib + &quot;; is it an APK or JAR? &quot;
                        + e.getMessage());
            }
        }
    }
}<br></div></div>

<p>Here first get the abi list of the current Android device, that is, armeabi,
armeabi-v7a, arm64-v8a and so on.</p>
<p>Then in each abi case, use DexFile.getDexOptNeeded to check if the library has
executed dexopt.</p>
<p>NO_DEXOPT_NEEDED &#xFF1A;if the apk/jar is already up to date.</p>
<p>DEX2OAT_NEEDED&#xFF1A; if dex2oat should be called on the apk/jar file.</p>
<p>PATCHOAT_NEEDED&#xFF1A;if patchoat should be called on the apk/jar file to patch the
odex file along side the apk/jar.</p>
<p>SELF_PATCHOAT_NEEDED if selfpatchoat should be called on the apk/jar file to
patch the oat file in the dalvik cache.</p>
<p>When the result is not NO_DEXOPT_NEEDED, the library needs dexopt. The dexopt
operation is performed by the dexopt of mInstaller.</p>
<p>carry on:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">File frameworkDir = new File(Environment.getRootDirectory(), &quot;framework&quot;);//&quot;/system/framework&quot;

// Gross hack for now: we know this file doesn&apos;t contain any
// code, so don&apos;t dexopt it to avoid the resulting log spew.
alreadyDexOpted.add(frameworkDir.getPath() + &quot;/framework-res.apk&quot;);

// Gross hack for now: we know this file is only part of
// the boot class path for art, so don&apos;t dexopt it to
// avoid the resulting log spew.
alreadyDexOpted.add(frameworkDir.getPath() + &quot;/core-libart.jar&quot;);

/**
 * There are a number of commands implemented in Java, which
 * we currently need to do the dexopt on so that they can be
 * run from a non-root shell.
 */
String[] frameworkFiles = frameworkDir.list();
if (frameworkFiles != null) {
    // TODO: We could compile these only for the most preferred ABI. We should
    // first double check that the dex files for these commands are not referenced
    // by other system apps.
    for (String dexCodeInstructionSet : dexCodeInstructionSets) {
        for (int i=0; i&lt;frameworkFiles.length; i++) {
            File libPath = new File(frameworkDir, frameworkFiles[i]);
            String path = libPath.getPath();
            // Skip the file if we already did it.
            if (alreadyDexOpted.contains(path)) {
                continue;
            }
            // Skip the file if it is not a type we want to dexopt.
            if (!path.endsWith(&quot;.apk&quot;) &amp;&amp; !path.endsWith(&quot;.jar&quot;)) {
                continue;//&#x8DF3;&#x8FC7;&#x90A3;&#x4E9B;&#x975E;apk&#x548C;jar&#x7684;&#x6587;&#x4EF6;
            }
            try {
                int dexoptNeeded = DexFile.getDexOptNeeded(path, null, dexCodeInstructionSet, false);
                if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
                    mInstaller.dexopt(path, Process.SYSTEM_UID, true, dexCodeInstructionSet, dexoptNeeded);
                }
            } catch (FileNotFoundException e) {
                Slog.w(TAG, &quot;Jar not found: &quot; + path);
            } catch (IOException e) {
                Slog.w(TAG, &quot;Exception reading jar: &quot; + path, e);
            }
        }
    }
}<br></div></div>

<p>will</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;sh&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">/system/framework/framework-res.apk
/system/framework/core-libart.jar<br></div></div>

<p>These two files are added to the optimized list alreadyDexOpted.</p>
<p>Then search for the jar/apk file in /system/framework that does not yet have
dexopt, and perform the dexopt operation.</p>
<p>carry on:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">final VersionInfo ver = mSettings.getInternalVersion();
mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);
// when upgrading from pre-M, promote system app permissions from install to runtime
mPromoteSystemApps =
        mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;

// save off the names of pre-existing system packages prior to scanning; we don&apos;t
// want to automatically grant runtime permissions for new system apps
if (mPromoteSystemApps) {
    Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator();
    while (pkgSettingIter.hasNext()) {
        PackageSetting ps = pkgSettingIter.next();
        if (isSystemApp(ps)) {
            mExistingSystemPackages.add(ps.name);
        }
    }
}<br></div></div>

<p>If you are upgrading the system, if you do not perform a system upgrade, ignore
this code.</p>
<p>In the next process, you will encounter a very important function of the PMS:
scanDirLI</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">// Collect vendor overlay packages.
// (Do this before scanning any apps.)
// For security and version matching reason, only consider
// overlay packages if they reside in VENDOR_OVERLAY_DIR.
File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);
scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM
        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0);

// Find base frameworks (resource packages without code).
scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM
        | PackageParser.PARSE_IS_SYSTEM_DIR
        | PackageParser.PARSE_IS_PRIVILEGED,
        scanFlags | SCAN_NO_DEX, 0);

// Collected privileged system packages.
final File privilegedAppDir = new File(Environment.getRootDirectory(), &quot;priv-app&quot;);
scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM
        | PackageParser.PARSE_IS_SYSTEM_DIR
        | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);

// Collect ordinary system packages.
final File systemAppDir = new File(Environment.getRootDirectory(), &quot;app&quot;);
scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM
        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);

// Collect all vendor packages.
File vendorAppDir = new File(&quot;/vendor/app&quot;);
try {
    vendorAppDir = vendorAppDir.getCanonicalFile();
} catch (IOException e) {
    // failed to look up canonical path, continue with original one
}
scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM
        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);

// Collect all OEM packages.
final File oemAppDir = new File(Environment.getOemDirectory(), &quot;app&quot;);
scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM
        | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);<br></div></div>

<p>The scanDirLI method is called in turn to scan the apk files in the following
directories.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;sh&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">/vendor/overlay
/system/framework
/system/priv-app
/system/app
/vendor/app
/oem/app<br></div></div>

<p>scanDirLI method code:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) {
        final File[] files = dir.listFiles();
        if (ArrayUtils.isEmpty(files)) {
            Log.d(TAG, &quot;No files in app dir &quot; + dir);
            return;// Will traverse all the files from the incoming dir, if there is no file, return directly
        }

        if (DEBUG_PACKAGE_SCANNING) {
            Log.d(TAG, &quot;Scanning app dir &quot; + dir + &quot; scanFlags=&quot; + scanFlags
                    + &quot; flags=0x&quot; + Integer.toHexString(parseFlags));
        }

        for (File file : files) {// If there is a file, it will be traversed

          // Determine whether a file is an apk file (ending with apk), or a folder and the folder satisfies the condition of isStageName
            final boolean isPackage = (isApkFile(file) || file.isDirectory())
                    &amp;&amp; !PackageInstallerService.isStageName(file.getName());
            if (!isPackage) {
                // Ignore entries which are not packages
                continue;
            }
            try {
               // Will call scanPackageLI for the next analysis
                scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,
                        scanFlags, currentTime, null);
            } catch (PackageManagerException e) {
                Slog.w(TAG, &quot;Failed to parse &quot; + file + &quot;: &quot; + e.getMessage());

                // Delete invalid userdata apps
                if ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) == 0 &amp;&amp;
                        e.error == PackageManager.INSTALL_FAILED_INVALID_APK) {
                    // The apk will only be deleted if the non-systematic apk scan fails.
                    logCriticalInfo(Log.WARN, &quot;Deleting invalid package at &quot; + file);
                    if (file.isDirectory()) {
                        mInstaller.rmPackageDir(file.getAbsolutePath());
                    } else {
                        file.delete();
                    }
                }
            }
        }
    }
    public static boolean isStageName(String name) {
         final boolean isFile = name.startsWith(&quot;vmdl&quot;) &amp;&amp; name.endsWith(&quot;.tmp&quot;);
         final boolean isContainer = name.startsWith(&quot;smdl&quot;) &amp;&amp; name.endsWith(&quot;.tmp&quot;);
         final boolean isLegacyContainer = name.startsWith(&quot;smdl2tmp&quot;);
         return isFile || isContainer || isLegacyContainer;
     }<br></div></div>

<p>After finding the apk file, scanPackageLI is called to parse the file and
convert the apk to a PackageParser.Package object.</p>
<p>Source location:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;sh&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">Android-6.0/framworks/base/core/java/android/content/pm/PackageParser.java<br></div></div>

<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">public  final  static  class  Package  {

        public String packageName;

        /** Names of any split APKs, ordered by parsed splitName */
        public String[] splitNames;

        // TODO: work towards making these paths invariant

        public String volumeUuid;

        /**
         * Path where this package was found on disk. For monolithic packages
         * this is path to single base APK file; for cluster packages this is
         * path to the cluster directory.
         */
        public String codePath;

        /** Path of base APK */
        public String baseCodePath;
        /** Paths of any split APKs, ordered by parsed splitName */
        public String[] splitCodePaths;

        /** Revision code of base APK */
        public int baseRevisionCode;
        /** Revision codes of any split APKs, ordered by parsed splitName */
        public int[] splitRevisionCodes;

        /** Flags of any split APKs; ordered by parsed splitName */
        public int[] splitFlags;
        ...............................<br></div></div>

<p>PackageParser.Package is a representative of an apk file in the PMS. The information about the apk is obtained by the pm command, which is represented by this class. It records information such as the package name of the apk.</p>
<p>The amount of code in scanPackageLI is also very large, so it is also parsed in sections.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags,
            long currentTime, UserHandle user) throws PackageManagerException {
        if (DEBUG_INSTALL) Slog.d(TAG, &quot;Parsing: &quot; + scanFile);
        parseFlags |= mDefParseFlags;
        PackageParser pp = new PackageParser();
        pp.setSeparateProcesses(mSeparateProcesses);
        pp.setOnlyCoreApps(mOnlyCore);
        pp.setDisplayMetrics(mMetrics);

        if ((scanFlags &amp; SCAN_TRUSTED_OVERLAY) != 0) {
            parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY;
        }

        final PackageParser.Package pkg;
        try {
            pkg = pp.parsePackage(scanFile, parseFlags);
        } catch (PackageParserException e) {
            throw PackageManagerException.from(e);
        }
.................<br></div></div>

<p>scanPackageLI creates a file parser, PackageParser, which is then parsed by the
parsePackage method of the parser.</p>
<p>Continue with scanPackageLI:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">PackageSetting ps = null;
PackageSetting updatedPkg;
// reader
synchronized (mPackages) {
    // Look to see if we already know about this package.
    String oldName = mSettings.mRenamedPackages.get(pkg.packageName);
    if (pkg.mOriginalPackages != null &amp;&amp; pkg.mOriginalPackages.contains(oldName)) {
        // This package has been renamed to its original name.  Let&apos;s
        // use that.
        ps = mSettings.peekPackageLPr(oldName);
    }
    // If there was no original package, see one for the real package name.
    if (ps == null) {
      //When the device is not booting for the first time, it will parse the packages.xml and store the pacakge recorded in the mPackages of mSettings. It is an ArrayMap&lt;String, PackageSetting&gt; variable.
      // package names to detect whether there is a scanned the ps, PackageSetting:Settings data for a particular package we know about.
      ps = mSettings.peekPackageLPr (pkg.packageName);
    }<br></div></div>

<p>This is mainly to deal with the inconsistency of the package name after the
application is upgraded. When the device is powered on for the first time, there
is no such situation. In other cases, open the opportunity to parse the
packages.xml. When the package name of the apk changes, the app will be in the
packages.xml.Tag tag. 
It also counts the information changed by the package name into the ArrayMap of
the mSettings variable of the PMS. In the type variable mRenamedPackages, the
key is newname.</p>
<p>Continue with scanPackageLI:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">// Check to see if this package could be hiding/updating a system
// package.  Must look for it either under the original or real
// package name depending on our state.
updatedPkg = mSettings.getDisabledSystemPkgLPr(ps != null ? ps.name : pkg.packageName);
if (DEBUG_INSTALL &amp;&amp; updatedPkg != null) Slog.d(TAG, &quot;updatedPkg = &quot; + updatedPkg);
}
boolean updatedPkgBetter = false;
// First check if this is a system package that may involve an update
if (updatedPkg != null &amp;&amp; (parseFlags&amp;PackageParser.PARSE_IS_SYSTEM) != 0) {
// If new package is not located in &quot;/system/priv-app&quot; (e.g. due to an OTA),
// it needs to drop FLAG_PRIVILEGED.
if (locationIsPrivileged(scanFile)) {
    updatedPkg.pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
} else {
    updatedPkg.pkgPrivateFlags &amp;= ~ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
}

if (ps != null &amp;&amp; !ps.codePath.equals(scanFile)) {
    // The path has changed from what was last scanned...  check the
    // version of the new path against what we have stored to determine
    // what to do.
    if (DEBUG_INSTALL) Slog.d(TAG, &quot;Path changing from &quot; + ps.codePath);
    if (pkg.mVersionCode &lt;= ps.versionCode) {
        // The system package has been updated and the code path does not match
        // Ignore entry. Skip it.
        if (DEBUG_INSTALL) Slog.i(TAG, &quot;Package &quot; + ps.name + &quot; at &quot; + scanFile
                + &quot; ignored: updated version &quot; + ps.versionCode
                + &quot; better than this &quot; + pkg.mVersionCode);
        if (!updatedPkg.codePath.equals(scanFile)) {
            Slog.w(PackageManagerService.TAG, &quot;Code path for hidden system pkg : &quot;
                    + ps.name + &quot; changing from &quot; + updatedPkg.codePathString
                    + &quot; to &quot; + scanFile);
            updatedPkg.codePath = scanFile;
            updatedPkg.codePathString = scanFile.toString();
            updatedPkg.resourcePath = scanFile;
            updatedPkg.resourcePathString = scanFile.toString();
        }
        updatedPkg.pkg = pkg;
        throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE,
                &quot;Package &quot; + ps.name + &quot; at &quot; + scanFile
                        + &quot; ignored: updated version &quot; + ps.versionCode
                        + &quot; better than this &quot; + pkg.mVersionCode);
    } else {
        // The current app on the system partition is better than
        // what we have updated to on the data partition; switch
        // back to the system partition version.
        // At this point, its safely assumed that package installation for
        // apps in system partition will go through. If not there won&apos;t be a working
        // version of the app
        // writer
        synchronized (mPackages) {
            // Just remove the loaded entries from package lists.
            mPackages.remove(ps.name);
        }

        logCriticalInfo(Log.WARN, &quot;Package &quot; + ps.name + &quot; at &quot; + scanFile
                + &quot; reverting from &quot; + ps.codePathString
                + &quot;: new version &quot; + pkg.mVersionCode
                + &quot; better than installed &quot; + ps.versionCode);

        InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps),
                ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
        synchronized (mInstallLock) {
            args.cleanUpResourcesLI();
        }
        synchronized (mPackages) {
            mSettings.enableSystemPackageLPw(ps.name);
        }
        updatedPkgBetter = true;
    }
}
}

if (updatedPkg != null) {
// An updated system app will not have the PARSE_IS_SYSTEM flag set
// initially
parseFlags |= PackageParser.PARSE_IS_SYSTEM;

// An updated privileged app will not have the PARSE_IS_PRIVILEGED
// flag set initially
if ((updatedPkg.pkgPrivateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {
    parseFlags |= PackageParser.PARSE_IS_PRIVILEGED;
}
}    // Check to see if this package could be hiding/updating a system
    // package.  Must look for it either under the original or real
    // package name depending on our state.
    updatedPkg = mSettings.getDisabledSystemPkgLPr(ps != null ? ps.name : pkg.packageName);
    if (DEBUG_INSTALL &amp;&amp; updatedPkg != null) Slog.d(TAG, &quot;updatedPkg = &quot; + updatedPkg);
}
boolean updatedPkgBetter = false;
// First check if this is a system package that may involve an update
if (updatedPkg != null &amp;&amp; (parseFlags&amp;PackageParser.PARSE_IS_SYSTEM) != 0) {
    // If new package is not located in &quot;/system/priv-app&quot; (e.g. due to an OTA),
    // it needs to drop FLAG_PRIVILEGED.
    if (locationIsPrivileged(scanFile)) {
        updatedPkg.pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
    } else {
        updatedPkg.pkgPrivateFlags &amp;= ~ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
    }

    if (ps != null &amp;&amp; !ps.codePath.equals(scanFile)) {
        // The path has changed from what was last scanned...  check the
        // version of the new path against what we have stored to determine
        // what to do.
        if (DEBUG_INSTALL) Slog.d(TAG, &quot;Path changing from &quot; + ps.codePath);
        if (pkg.mVersionCode &lt;= ps.versionCode) {
            // The system package has been updated and the code path does not match
            // Ignore entry. Skip it.
            if (DEBUG_INSTALL) Slog.i(TAG, &quot;Package &quot; + ps.name + &quot; at &quot; + scanFile
                    + &quot; ignored: updated version &quot; + ps.versionCode
                    + &quot; better than this &quot; + pkg.mVersionCode);
            if (!updatedPkg.codePath.equals(scanFile)) {
                Slog.w(PackageManagerService.TAG, &quot;Code path for hidden system pkg : &quot;
                        + ps.name + &quot; changing from &quot; + updatedPkg.codePathString
                        + &quot; to &quot; + scanFile);
                updatedPkg.codePath = scanFile;
                updatedPkg.codePathString = scanFile.toString();
                updatedPkg.resourcePath = scanFile;
                updatedPkg.resourcePathString = scanFile.toString();
            }
            updatedPkg.pkg = pkg;
            throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE,
                    &quot;Package &quot; + ps.name + &quot; at &quot; + scanFile
                            + &quot; ignored: updated version &quot; + ps.versionCode
                            + &quot; better than this &quot; + pkg.mVersionCode);
        } else {
            // The current app on the system partition is better than
            // what we have updated to on the data partition; switch
            // back to the system partition version.
            // At this point, its safely assumed that package installation for
            // apps in system partition will go through. If not there won&apos;t be a working
            // version of the app
            // writer
            synchronized (mPackages) {
                // Just remove the loaded entries from package lists.
                mPackages.remove(ps.name);
            }

            logCriticalInfo(Log.WARN, &quot;Package &quot; + ps.name + &quot; at &quot; + scanFile
                    + &quot; reverting from &quot; + ps.codePathString
                    + &quot;: new version &quot; + pkg.mVersionCode
                    + &quot; better than installed &quot; + ps.versionCode);

            InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps),
                    ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
            synchronized (mInstallLock) {
                args.cleanUpResourcesLI();
            }
            synchronized (mPackages) {
                mSettings.enableSystemPackageLPw(ps.name);
            }
            updatedPkgBetter = true;
        }
    }
}

if (updatedPkg != null) {
    // An updated system app will not have the PARSE_IS_SYSTEM flag set
    // initially
    parseFlags |= PackageParser.PARSE_IS_SYSTEM;

    // An updated privileged app will not have the PARSE_IS_PRIVILEGED
    // flag set initially
    if ((updatedPkg.pkgPrivateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {
        parseFlags |= PackageParser.PARSE_IS_PRIVILEGED;
    }
}<br></div></div>

<p>Here is to deal with the installation of the system update, check whether it has
an impact on the system app. That is, whether to update the system app to a
newer version. If so, we have to deal with it.</p>
<p>Next is the signature of the scan apk.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">// Verify certificates against what was last scanned
collectCertificatesLI(pp, ps, pkg, scanFile, parseFlags);<br></div></div>


<p>Continue with scanPackageLI:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">/*
 * A new system app appeared, but we already had a non-system one of the
 * same name installed earlier.
 */
boolean shouldHideSystemApp = false;
if (updatedPkg == null &amp;&amp; ps != null
        &amp;&amp; (parseFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) != 0 &amp;&amp; !isSystemApp(ps)) {
    /*
     * Check to make sure the signatures match first. If they don&apos;t,
     * wipe the installed application and its data.
     */
    if (compareSignatures(ps.signatures.mSignatures, pkg.mSignatures)
            != PackageManager.SIGNATURE_MATCH) {
        logCriticalInfo(Log.WARN, &quot;Package &quot; + ps.name + &quot; appeared on system, but&quot;
                + &quot; signatures don&apos;t match existing userdata copy; removing&quot;);
        deletePackageLI(pkg.packageName, null, true, null, null, 0, null, false);
        ps = null;
    } else {
        /*
         * If the newly-added system app is an older version than the
         * already installed version, hide it. It will be scanned later
         * and re-added like an update.
         */
        if (pkg.mVersionCode &lt;= ps.versionCode) {
            shouldHideSystemApp = true;
            logCriticalInfo(Log.INFO, &quot;Package &quot; + ps.name + &quot; appeared at &quot; + scanFile
                    + &quot; but new version &quot; + pkg.mVersionCode + &quot; better than installed &quot;
                    + ps.versionCode + &quot;; hiding system&quot;);
        } else {
            /*
             * The newly found system app is a newer version that the
             * one previously installed. Simply remove the
             * already-installed application and replace it with our own
             * while keeping the application data.
             */
            logCriticalInfo(Log.WARN, &quot;Package &quot; + ps.name + &quot; at &quot; + scanFile
                    + &quot; reverting from &quot; + ps.codePathString + &quot;: new version &quot;
                    + pkg.mVersionCode + &quot; better than installed &quot; + ps.versionCode);
            InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps),
                    ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
            synchronized (mInstallLock) {
                args.cleanUpResourcesLI();
            }
        }
    }
}<br></div></div>

<p>The code here is to deal with the situation: when the system is updated, the
update package may have some system app out, then if the user happens to install
an app with the same package name. The signatures of the two are still
inconsistent, then delete Information about the scanned system application.</p>
<p>When the two signatures are the same, if the scanned version of the app is
higher, the installed application is deleted; if the scanned version of the
application is low, the scanned system application is hidden.</p>
<p>Continue with scanPackageLI:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">// The apk is forward locked (not public) if its code and resources
// are kept in different files. (except for app in either system or
// vendor path).
// TODO grab this value from PackageSettings
if ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
    if (ps != null &amp;&amp; !ps.codePath.equals(ps.resourcePath)) {
        parseFlags |= PackageParser.PARSE_FORWARD_LOCK;
    }
}

// TODO: extend to support forward-locked splits
String resourcePath = null;
String baseResourcePath = null;
if ((parseFlags &amp; PackageParser.PARSE_FORWARD_LOCK) != 0 &amp;&amp; !updatedPkgBetter) {
    if (ps != null &amp;&amp; ps.resourcePathString != null) {
        resourcePath = ps.resourcePathString;
        baseResourcePath = ps.resourcePathString;
    } else {
        // Should not happen at all. Just log an error.
        Slog.e(TAG, &quot;Resource path not set for pkg : &quot; + pkg.packageName);
    }
} else {
    resourcePath = pkg.codePath;
    baseResourcePath = pkg.baseCodePath;
}

// Set application objects path explicitly.
pkg.applicationInfo.volumeUuid = pkg.volumeUuid;
pkg.applicationInfo.setCodePath(pkg.codePath);
pkg.applicationInfo.setBaseCodePath(pkg.baseCodePath);
pkg.applicationInfo.setSplitCodePaths(pkg.splitCodePaths);
pkg.applicationInfo.setResourcePath(resourcePath);
pkg.applicationInfo.setBaseResourcePath(baseResourcePath);
pkg.applicationInfo.setSplitResourcePaths(pkg.splitCodePaths);<br></div></div>

<p>Handle the application&apos;s code path and resource path.</p>
<p>Continue with scanPackageLI:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">// Note that we invoke the following method only if we are about to unpack an application
PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags
        | SCAN_UPDATE_SIGNATURE, currentTime, user);<br></div></div>

<p>Call another packagePackageLI of PackageParser to continue processing, and then
analyze it.</p>
<p>Continue with scanPackageLI:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">/*
 * If the system app should be overridden by a previously installed
 * data, hide the system app now and let the /data/app scan pick it up
 * again.
 */
if (shouldHideSystemApp) {
    synchronized (mPackages) {
        mSettings.disableSystemPackageLPw(pkg.packageName);
    }
}

return scannedPkg;
}<br></div></div>

<p>If the scanned system app needs to be hidden, its information is recorded in the
mDisabledSysPackages of mSettings via the mSettings.disableSystemPackageLPw
method.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="Android PMS - Android 6 PMS Analysis.html" class="navigation navigation-prev " aria-label="Previous page: Android PMS - Android 6 PMS Analysis">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="Android PMS - Android 6 PMS analysis article 2.html" class="navigation navigation-next " aria-label="Next page: Android PMS - Android 6 PMS analysis article 2">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Android PMS - Android 6 PMS analysis article 1","level":"1.5.4","depth":2,"next":{"title":"Android PMS - Android 6 PMS analysis article 2","level":"1.5.5","depth":2,"path":"Android PMS - Android 6 PMS analysis article 2.md","ref":"Android PMS - Android 6 PMS analysis article 2.md","articles":[]},"previous":{"title":"Android PMS - Android 6 PMS Analysis","level":"1.5.3","depth":2,"path":"Android PMS - Android 6 PMS Analysis.md","ref":"Android PMS - Android 6 PMS Analysis.md","articles":[]},"dir":"ltr"},"config":{"plugins":["include-html","fancybox","anchor-navigation-ex-toc","ace","-lunr","-search","search-plus","hide-published-with","splitter","expandable-chapters-interactive","wide-page"],"root":"./docs","styles":{"website":"styles/website.css"},"pluginsConfig":{"fancybox":{"helpers":{"buttons":{}}},"ace":{},"splitter":{},"wide-page":{},"anchor-navigation-ex-toc":{"showLevel":true,"associatedWithSummary":true,"mode":"float","printLog":false,"multipleH1":true,"float":{"showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""},"pageTop":{"showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""}},"hide-published-with":{},"include-html":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"expandable-chapters-interactive":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"expandable-chapters":{},"search-plus":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"gitbook":"*"},"file":{"path":"Android PMS - Android 6 PMS analysis article 1.md","mtime":"2018-09-20T08:59:32.236Z","type":"markdown"},"gitbook":{"version":"3.3.6","time":"2023-12-10T09:35:29.798Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.mousewheel.pack.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.fancybox.pack.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.fancybox-buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-ace/ace/ace.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-ace/ace.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search-plus/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-hide-published-with/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-interactive/expandable-chapters.js"></script>
        
    
        
        <script src="gitbook/@gitbook-ng/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

