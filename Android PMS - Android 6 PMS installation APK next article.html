
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Android PMS - Android 6 PMS installation APK next article Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="@gitbook-ng/gitbook 3.3.6">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fancybox/jquery.fancybox.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fancybox/jquery.fancybox-buttons.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-anchor-navigation-ex-toc/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-ace/ace.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search-plus/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-interactive/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-wide-page/wide.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="styles/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="Android PMS - Android 6 PMS Uninstall APK.html" />
    
    
    <link rel="prev" href="Android PMS - Android 6 PMS installation APK.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    Graphical Android
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="Graphical Android - Zygote, System Server startup analysis.html">
            
                <a href="Graphical Android - Zygote, System Server startup analysis.html">
            
                    
                    Graphical Android - Zygote, System Server startup analysis
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    Android Permissions
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="Android Permissions - Android Runtime Permission.html">
            
                <a href="Android Permissions - Android Runtime Permission.html">
            
                    
                    Android Permissions - Android Runtime Permission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="Android Permissions - Android grantRuntimePermission Detailed.html">
            
                <a href="Android Permissions - Android grantRuntimePermission Detailed.html">
            
                    
                    Android Permissions - Android grantRuntimePermission Detailed
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="Android Permissions - Android GrantPermissionsActivity Detailed.html">
            
                <a href="Android Permissions - Android GrantPermissionsActivity Detailed.html">
            
                    
                    Android Permissions - Android GrantPermissionsActivity Detailed
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="Android Permissions - AppOps control for Normal permission.html">
            
                <a href="Android Permissions - AppOps control for Normal permission.html">
            
                    
                    Android Permissions - AppOps control for Normal permission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="Android Permissions - Android native permission control process.html">
            
                <a href="Android Permissions - Android native permission control process.html">
            
                    
                    Android Permissions - Android native permission control process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="Android Permissions - The difference between setUidMode and setMode in AppOps.html">
            
                <a href="Android Permissions - The difference between setUidMode and setMode in AppOps.html">
            
                    
                    Android Permissions - The difference between setUidMode and setMode in AppOps
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="Android Permissions - Application permissions before android M and application permissions after M.html">
            
                <a href="Android Permissions - Application permissions before android M and application permissions after M.html">
            
                    
                    Android Permissions - Application permissions before android M and application permissions after M
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="Android Permissions - Provider permissions detailed.html">
            
                <a href="Android Permissions - Provider permissions detailed.html">
            
                    
                    Android Permissions - Provider permissions detailed
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    Android OTA
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="Android OTA - Android OTA upgrade principle and process analysis 1.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 1.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="Android OTA - Android OTA upgrade principle and process analysis 2.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 2.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="Android OTA - Android OTA upgrade principle and process analysis 3.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 3.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="Android OTA - Android OTA upgrade principle and process analysis 4.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 4.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 4
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="Android OTA - Android OTA upgrade principle and process analysis 5.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 5.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="Android OTA - Android OTA upgrade principle and process analysis 6.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 6.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.7" data-path="Android OTA - Android OTA upgrade principle and process analysis 7.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 7.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 7
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.8" data-path="Android OTA - Android OTA upgrade principle and process analysis 8.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 8.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 8
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.9" data-path="Android OTA - Android OTA upgrade principle and process analysis 9.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 9.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 9
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" >
            
                <span>
            
                    
                    Android Package Manager Service (PMS)
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="Android PMS - Explore the Android PMS service.html">
            
                <a href="Android PMS - Explore the Android PMS service.html">
            
                    
                    Android PMS - Explore the Android PMS service
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="Android PMS - Some rules of the PMS runtime.html">
            
                <a href="Android PMS - Some rules of the PMS runtime.html">
            
                    
                    Android PMS - Some rules of the PMS runtime
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="Android PMS - Android 6 PMS Analysis.html">
            
                <a href="Android PMS - Android 6 PMS Analysis.html">
            
                    
                    Android PMS - Android 6 PMS Analysis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="Android PMS - Android 6 PMS analysis article 1.html">
            
                <a href="Android PMS - Android 6 PMS analysis article 1.html">
            
                    
                    Android PMS - Android 6 PMS analysis article 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="Android PMS - Android 6 PMS analysis article 2.html">
            
                <a href="Android PMS - Android 6 PMS analysis article 2.html">
            
                    
                    Android PMS - Android 6 PMS analysis article 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.6" data-path="Android PMS - Android 6 PMS analysis of the next article.html">
            
                <a href="Android PMS - Android 6 PMS analysis of the next article.html">
            
                    
                    Android PMS - Android 6 PMS analysis of the next article
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.7" data-path="Android PMS - Android 6 PMS install APK prelude.html">
            
                <a href="Android PMS - Android 6 PMS install APK prelude.html">
            
                    
                    Android PMS - Android 6 PMS install APK prelude
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.8" data-path="Android PMS - Android 6 PMS installation APK.html">
            
                <a href="Android PMS - Android 6 PMS installation APK.html">
            
                    
                    Android PMS - Android 6 PMS installation APK
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.5.9" data-path="Android PMS - Android 6 PMS installation APK next article.html">
            
                <a href="Android PMS - Android 6 PMS installation APK next article.html">
            
                    
                    Android PMS - Android 6 PMS installation APK next article
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.10" data-path="Android PMS - Android 6 PMS Uninstall APK.html">
            
                <a href="Android PMS - Android 6 PMS Uninstall APK.html">
            
                    
                    Android PMS - Android 6 PMS Uninstall APK
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.11" data-path="Android PMS - Android 6 PMS daemon installd.html">
            
                <a href="Android PMS - Android 6 PMS daemon installd.html">
            
                    
                    Android PMS - Android 6 PMS daemon installd
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" >
            
                <span>
            
                    
                    Android AOSP
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="Android AOSP - Debugging AOSP Platform code with Android Studio - Java Debugger.html">
            
                <a href="Android AOSP - Debugging AOSP Platform code with Android Studio - Java Debugger.html">
            
                    
                    Android AOSP - Debugging AOSP Platform code with Android Studio - Java Debugger
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="Android AOSP - Modify applications and rebuild emulator image effectively.html">
            
                <a href="Android AOSP - Modify applications and rebuild emulator image effectively.html">
            
                    
                    Android AOSP - Modify applications and rebuild emulator image effectively
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" >
            
                <span>
            
                    
                    Android General
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="Android General - Reliable connection to AIDL IPC Service in Android.html">
            
                <a href="Android General - Reliable connection to AIDL IPC Service in Android.html">
            
                    
                    Android General - Reliable connection to AIDL IPC Service in Android
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" >
            
                <span>
            
                    
                    Android Binder
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" >
            
                <span>
            
                    
                    Android Activity Manager Service (AMS)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" >
            
                <span>
            
                    
                    Live555
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="Live555 - Live555 source code analysis_introduction.html">
            
                <a href="Live555 - Live555 source code analysis_introduction.html">
            
                    
                    Live555 - Live555 source code analysis_introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="Live555 - Live555 source code analysis_infrastructure.html">
            
                <a href="Live555 - Live555 source code analysis_infrastructure.html">
            
                    
                    Live555 - Live555 source code analysis_infrastructure
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="Live555 - Live555 source code analysis_mediaserver.html">
            
                <a href="Live555 - Live555 source code analysis_mediaserver.html">
            
                    
                    Live555 - Live555 source code analysis_mediaserver
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="Live555 - Wireshark capture packet analysis RTSP_RTP_RTCP basic working process.html">
            
                <a href="Live555 - Wireshark capture packet analysis RTSP_RTP_RTCP basic working process.html">
            
                    
                    Live555 - Wireshark capture packet analysis RTSP_RTP_RTCP basic working process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="Live555 - Live555 source code analysis_rtspserver.html">
            
                <a href="Live555 - Live555 source code analysis_rtspserver.html">
            
                    
                    Live555 - Live555 source code analysis_rtspserver
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.6" data-path="Live555 - Live555 source code analysis_describe processing.html">
            
                <a href="Live555 - Live555 source code analysis_describe processing.html">
            
                    
                    Live555 - Live555 source code analysis_describe processing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.7" data-path="Live555 - Live555 source code analysis_setup processing.html">
            
                <a href="Live555 - Live555 source code analysis_setup processing.html">
            
                    
                    Live555 - Live555 source code analysis_setup processing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.8" data-path="Live555 - Live555 source code analysis_play processing.html">
            
                <a href="Live555 - Live555 source code analysis_play processing.html">
            
                    
                    Live555 - Live555 source code analysis_play processing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.9" data-path="Live555 - Live555 source code analysis_RTSPServer component structure.html">
            
                <a href="Live555 - Live555 source code analysis_RTSPServer component structure.html">
            
                    
                    Live555 - Live555 source code analysis_RTSPServer component structure
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.10" data-path="Live555 - Live555 source code analysis_servermediasession.html">
            
                <a href="Live555 - Live555 source code analysis_servermediasession.html">
            
                    
                    Live555 - Live555 source code analysis_servermediasession
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.11" data-path="Live555 - Live555 source code analysis_subsession SDP line generation.html">
            
                <a href="Live555 - Live555 source code analysis_subsession SDP line generation.html">
            
                    
                    Live555 - Live555 source code analysis_subsession SDP line generation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.12" data-path="Live555 - Live555 source code analysis_Subsession SETUP.html">
            
                <a href="Live555 - Live555 source code analysis_Subsession SETUP.html">
            
                    
                    Live555 - Live555 source code analysis_Subsession SETUP
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.13" data-path="Live555 - Live555 source code analysis_play start.html">
            
                <a href="Live555 - Live555 source code analysis_play start.html">
            
                    
                    Live555 - Live555 source code analysis_play start
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11" >
            
                <span>
            
                    
                    Flutter
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="Flutter Framework Analysis 1 - Overview and Window.html">
            
                <a href="Flutter Framework Analysis 1 - Overview and Window.html">
            
                    
                    Flutter Framework Analysis 1 - Overview and Window
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="Flutter Framework Analysis 2 - Initialization.html">
            
                <a href="Flutter Framework Analysis 2 - Initialization.html">
            
                    
                    Flutter Framework Analysis 2 - Initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="Flutter Framework Analysis 3 - Widget, Element and RenderObject.html">
            
                <a href="Flutter Framework Analysis 3 - Widget, Element and RenderObject.html">
            
                    
                    Flutter Framework Analysis 3 - Widget, Element and RenderObject
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.4" data-path="Flutter Framework Analysis 4 - Flutter Framework Operation.html">
            
                <a href="Flutter Framework Analysis 4 - Flutter Framework Operation.html">
            
                    
                    Flutter Framework Analysis 4 - Flutter Framework Operation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.5" data-path="Flutter Framework Analysis 5 - Animation.html">
            
                <a href="Flutter Framework Analysis 5 - Animation.html">
            
                    
                    Flutter Framework Analysis 5 - Animation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.6" data-path="Flutter Framework Analysis 6 - Layout.html">
            
                <a href="Flutter Framework Analysis 6 - Layout.html">
            
                    
                    Flutter Framework Analysis 6 - Layout
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.7" data-path="Flutter Framework Analysis 7 - Drawing.html">
            
                <a href="Flutter Framework Analysis 7 - Drawing.html">
            
                    
                    Flutter Framework Analysis 7 - Drawing
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Android PMS - Android 6 PMS installation APK next article</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div class="search-plus" id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <div id="anchor-navigation-ex-navbar"><i class="fa fa-anchor"></i><ul><li><span class="title-icon "></span><a href="#android-6-pms-installation-apk-next-article"><b>1. </b>Android 6 PMS installation APK next article</a></li></ul></div><a href="#android-6-pms-installation-apk-next-article" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><h1 id="android-6-pms-installation-apk-next-article"><a name="android-6-pms-installation-apk-next-article" class="anchor-navigation-ex-anchor" href="#android-6-pms-installation-apk-next-article"><i class="fa fa-link" aria-hidden="true"></i></a>1. Android 6 PMS installation APK next article</h1>
<p><a href="http://www.iloveandroid.net/tags/Android%E6%A0%B8%E5%BF%83%E6%9C%8D%E5%8A%A1/" target="_blank">Android core service</a>
<a href="http://www.iloveandroid.net/categories/Android%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/" target="_blank">Android underlying development</a></p>
<p>Install an apk into: check permissions, copy files, and install them in the
app. The first two steps were analyzed before, and now the analysis of the app&apos;s
load is started.</p>
<p>In this step, the execution file of the oat format of converting the dex into
the ART virtual machine is completed, and the data sandbox directory is created
for the application, and finally the application information is loaded into the
data structure of the PMS.</p>
<p>In the startCopy method of HandlerParams called when MCS_BOUND is processed
earlier</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">final boolean startCopy() {
           boolean res;
           try {
    ...........................
               if (++mRetries &gt; MAX_RETRIES) {
        ....................................................
                   return false;
               } else {
                   handleStartCopy();
                   res = true;
               }
           } catch (RemoteException e) {
..............................
           }
           handleReturnCode();
           return res;
       }<br></div></div>

<p>You can know that when the file is copied, the handleReturnCode method of InstallParams is called:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">void handleReturnCode() {
           // If mArgs is null, then MCS couldn&apos;t be reached. When it
           // reconnects, it will try again to install. At that point, this
           // will succeed.
           if (mArgs != null) {
               processPendingInstall(mArgs, mRet);
           }
       }<br></div></div>

<p>code show as below:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">private void processPendingInstall(final InstallArgs args, final int currentStatus) {
       // Queue up an async operation since the package installation may take a little while.
       mHandler.post(new Runnable() {
           public void run() {
               mHandler.removeCallbacks(this);
                // Result object to be returned
               PackageInstalledInfo res = new PackageInstalledInfo();
               res.returnCode = currentStatus;
               res.uid = -1;
               res.pkg = null;
               res.removedInfo = new PackageRemovedInfo();
               if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
                    //Under normal circumstances, nothing will be done.
                   args.doPreInstall(res.returnCode);
                   synchronized (mInstallLock) {
                       installPackageLI(args, res);
                   }
                   args.doPostInstall(res.returnCode, res.uid);
               }
            .....................................
            /* Omit code about cloud backup */
            .....................................
               if (!doRestore) {
                   // No restore possible, or the Backup Manager was mysteriously not
                   // available -- just fire the post-install work request directly.
                   if (DEBUG_INSTALL) Log.v(TAG, &quot;No restore - queue post-install for &quot; + token);
                   Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);
                   mHandler.sendMessage(msg);
               }
           }
       });
   }<br></div></div>

<p>A message is posted in the processPendingInstall() method so that the
installation process continues in an asynchronous manner. In the post message,
the first is to call installPackageLI () to load the application, the next large
piece of code is in the device backup operation, the backup is done through the
BackupManagerService, here is not analyzed. After the backup is complete,
continue processing by sending a POST_INSTALL message.</p>
<p>doPreInstall() generally does not do anything. Then look at the
installPackageLI() method, the code is very long, so it is still parsed by
segmentation.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">Private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {

        / / Get installFlags, which records where the app needs to be installed
        final int installFlags = args.installFlags;
        // package name of the installer
        final String installerPackageName = args.installerPackageName;
        // related to sd card installation, generally null
        final String volumeUuid = args.volumeUuid;
        // I have previously copied the apk to the temporary stage folder /data/app/vmdl&lt;installation call id&gt;.tmp/ this directory
        final File tmpPackageFile = new File(args.getCodePath());
        // No setting INSTALL_FORWARD_LOCK
        final boolean forwardLocked = ((installFlags &amp; PackageManager.INSTALL_FORWARD_LOCK) != 0);
        // Whether to install to external storage
        final boolean onExternal = (((installFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0)
                || (args.volumeUuid != null));
        // Initialize the replacement flag to false
        Boolean replace = false;
        / / Set the browsing parameters
        int scanFlags = SCAN_NEW_INSTALL | SCAN_UPDATE_SIGNATURE;
        // We are not a mobile app, so it is null, don&apos;t take this code
        if (args.move != null) {
            // moving a complete application; perfom an initial scan on the new install location
            scanFlags |= SCAN_INITIAL;
        }
        / / Initialize the return code
        // Result object to be returned
        res.returnCode = PackageManager.INSTALL_SUCCEEDED;<br></div></div>

<p>Here is the work of doing some initialization values. See the above note for
details.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">if (DEBUG_INSTALL) Slog.d(TAG, &quot;installPackageLI: path=&quot; + tmpPackageFile);
      // Retrieve PackageSettings and parse package

      // Set parsing apk flags
      final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY
              | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0)
              | (onExternal ? PackageParser.PARSE_EXTERNAL_STORAGE : 0);

      // Create a parser
      PackageParser pp = new PackageParser();
      pp.setSeparateProcesses(mSeparateProcesses);
      // Get screen parameters
      pp.setDisplayMetrics(mMetrics);

      final PackageParser.Package pkg;
      try {
          // Start parsing apk, pay attention to passing tmpPackageFile as a folder at this time
          pkg = pp.parsePackage(tmpPackageFile, parseFlags);
      } catch (PackageParserException e) {
          res.setError(&quot;Failed parse during installPackageLI&quot;, e);
          return;
      }

      // Mark that we have an install time CPU ABI override.
      pkg.cpuAbiOverride = args.abiOverride;

      String pkgName = res.name = pkg.packageName;
      if ((pkg.applicationInfo.flags&amp;ApplicationInfo.FLAG_TEST_ONLY) != 0) {
          if ((installFlags &amp; PackageManager.INSTALL_ALLOW_TEST) == 0) {
              res.setError(INSTALL_FAILED_TEST_ONLY, &quot;installPackageLI&quot;);
              return;
          }
      }<br></div></div>

<p>The main thing here is to parse the APK, which is to parse the
AndroidMainifest.xml file and record the result in the PackageParser.Package. I
have already explained in detail how to parse an APK, so I won&apos;t go into details
here.</p>
<p>Next is to collect the signature information of apk, the code is as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">try {
            pp.collectCertificates(pkg, parseFlags);
            pp.collectManifestDigest(pkg);
        } catch (PackageParserException e) {
            res.setError(&quot;Failed collect during installPackageLI&quot;, e);
            return;
        }<br></div></div>

<p>If the installer has previously passed in a manifest file, then the parsed
manifest file is compared to the incoming one. The installer did pass in a list,
and the packageInstallerActivity also parsed the apk. At that time, the list was
recorded and passed in here. Here is another step to judge that the two are the
same apk.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">/* If the installer passed in a manifest digest, compare it now. */
        if (args.manifestDigest != null) {
            if (DEBUG_INSTALL) {
                final String parsedManifest = pkg.manifestDigest == null ? &quot;null&quot;
                        : pkg.manifestDigest.toString();
                Slog.d(TAG, &quot;Comparing manifests: &quot; + args.manifestDigest.toString() + &quot; vs. &quot;
                        + parsedManifest);
            }

            if (!args.manifestDigest.equals(pkg.manifestDigest)) {
                res.setError(INSTALL_FAILED_PACKAGE_CHANGED, &quot;Manifest digest changed&quot;);
                return;
            }
        } else if (DEBUG_INSTALL) {
            final String parsedManifest = pkg.manifestDigest == null
                    ? &quot;null&quot; : pkg.manifestDigest.toString();
            Slog.d(TAG, &quot;manifestDigest was not present, but parser got: &quot; + parsedManifest);
        }<br></div></div>

<p>Continue to analyze installPackageLI:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">// Check if installing already existing package
            // If installing an existing application, the PackageInstaller app installer will set INSTALL_REPLACE_EXISTING in installFlags
           if ((installFlags &amp; PackageManager.INSTALL_REPLACE_EXISTING) != 0) {

                / / Look at the package name of the apk to be replaced whether the original package name exists
                // When the app upgrade causes the package names to be inconsistent, the record needs to be the original package name.
                // So here we have to check if the app to be overwritten is like this. If so, set the package name to the old package name.
               String oldName = mSettings.mRenamedPackages.get(pkgName);
               if (pkg.mOriginalPackages != null
                       &amp;&amp; pkg.mOriginalPackages.contains(oldName)
                       &amp;&amp; mPackages.containsKey(oldName)) {
                   // This package is derived from an original package,
                   // and this device has been updating from that original
                   // name. We must continue using the original name, so
                   // rename the new package here.
                   pkg.setPackageName(oldName);
                   pkgName = pkg.packageName;
                   Replace = true;
                   if (DEBUG_INSTALL) Slog.d(TAG, &quot;Replacing existing renamed package: oldName=&quot;
                           + oldName + &quot; pkgName=&quot; + pkgName);
               } else if (mPackages.containsKey(pkgName)) {
                   // This package, under its official name, already exists
                   // on the device; we should replace it.
                   Replace = true;
                   if (DEBUG_INSTALL) Slog.d(TAG, &quot;Replace existing pacakge: &quot; + pkgName);
               }

               // Prevent apps opting out from runtime permissions
               / / Check the new app compiled when the target target version is lower than 6.0, and the original app compiled when the target is selected 6.0,
               / / When an app is compiled according to 6.0, you need to parse the permissions of the app according to the rules of 6.0.
               if (replace) {
                   PackageParser.Package oldPackage = mPackages.get(pkgName);
                   final int oldTargetSdk = oldPackage.applicationInfo.targetSdkVersion;
                   final int newTargetSdk = pkg.applicationInfo.targetSdkVersion;
                   if (oldTargetSdk &gt; Build.VERSION_CODES.LOLLIPOP_MR1
                           &amp;&amp; newTargetSdk &lt;= Build.VERSION_CODES.LOLLIPOP_MR1) {
                       res.setError(PackageManager.INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE,
                               &quot;Package &quot; + pkg.packageName + &quot; new target SDK &quot; + newTargetSdk
                                       + &quot; doesn&apos;t support runtime permissions but the old&quot;
                                       + &quot; target SDK &quot; + oldTargetSdk + &quot; does.&quot;);
                       Return;
                   }
               }
           }

           // If ps is not null, it also means that a program with the same package name already exists.
           // that is, it still handles the situation of overwriting the installation.
           // This is mainly to verify the signature of the package name. If it is inconsistent, it cannot be overwritten. In addition, the version number cannot be lower than the installation. Otherwise, it cannot be installed.
           PackageSetting ps = mSettings.mPackages.get(pkgName);
          if (ps != null) {
              if (DEBUG_INSTALL) Slog.d(TAG, &quot;Existing package: &quot; + ps);

              // Quick sanity check that we&apos;re signed correctly if updating;
              // we&apos;ll check this again later when scanning, but we want to
              // bail early here before tripping over redefined permissions.
              if (shouldCheckUpgradeKeySetLP(ps, scanFlags)) {
                  if (!checkUpgradeKeySetLP(ps, pkg)) {
                      res.setError(INSTALL_FAILED_UPDATE_INCOMPATIBLE, &quot;Package &quot;
                              + pkg.packageName + &quot; upgrade keys do not match the &quot;
                              + &quot;previously installed version&quot;);
                      Return;
                  }
              } else {
                  Try {
                      verifySignaturesLP(ps, pkg);
                  } catch (PackageManagerException e) {
                      res.setError(e.error, e.getMessage());
                      Return;
                  }
              }

              oldCodePath = mSettings.mPackages.get(pkgName).codePathString;
              if (ps.pkg != null &amp;&amp; ps.pkg.applicationInfo != null) {
                  systemApp = (ps.pkg.applicationInfo.flags &amp;
                          ApplicationInfo.FLAG_SYSTEM) != 0;
              }
              res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
          }<br></div></div>

<p>Here is mainly to set some variables when overwriting the installation.</p>
<p>Continue to analyze, the next step is to conduct a preliminary check on the
permissions defined by apk:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">// Check whether the newly-scanned package wants to define an already-defined perm
            int N = pkg.permissions.size();
            for (int i = N-1; i &gt;= 0; i--) {
                PackageParser.Permission perm = pkg.permissions.get(i);
                BasePermission bp = mSettings.mPermissions.get(perm.info.name);
                if (bp != null) {
                    // If the defining package is signed with our cert, it&apos;s okay.  This
                    // also includes the &quot;updating the same package&quot; case, of course.
                    // &quot;updating same package&quot; could also involve key-rotation.
                    final boolean sigsOk;
                    if (bp.sourcePackage.equals(pkg.packageName)
                            &amp;&amp; (bp.packageSetting instanceof PackageSetting)
                            &amp;&amp; (shouldCheckUpgradeKeySetLP((PackageSetting) bp.packageSetting,
                                    scanFlags))) {
                        sigsOk = checkUpgradeKeySetLP((PackageSetting) bp.packageSetting, pkg);
                    } else {
                        sigsOk = compareSignatures(bp.packageSetting.signatures.mSignatures,
                                pkg.mSignatures) == PackageManager.SIGNATURE_MATCH;
                    }
                    if (!sigsOk) {
                        // If the owning package is the system itself, we log but allow
                        // install to proceed; we fail the install on all other permission
                        // redefinitions.
                        if (!bp.sourcePackage.equals(&quot;android&quot;)) {
                            res.setError(INSTALL_FAILED_DUPLICATE_PERMISSION, &quot;Package &quot;
                                    + pkg.packageName + &quot; attempting to redeclare permission &quot;
                                    + perm.info.name + &quot; already owned by &quot; + bp.sourcePackage);
                            res.origPermission = perm.info.name;
                            res.origPackage = bp.sourcePackage;
                            return;
                        } else {
                            Slog.w(TAG, &quot;Package &quot; + pkg.packageName
                                    + &quot; attempting to redeclare system permission &quot;
                                    + perm.info.name + &quot;; ignoring new declaration&quot;);
                            pkg.permissions.remove(i);
                        }
                    }
                }
            }<br></div></div>

<p>The function of this code is to check whether all the permissions defined in the
apk have been defined by other applications. If the permissions defined by the
system application are redefined, then the permission defined by the app is
ignored. If you redefine the permissions of a non-system application, then this
installation will return with a failure.</p>
<p>Continue to analyze, when an app is a system application, but wants to install
in external storage, then an error is reported.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">if (systemApp &amp;&amp; onExternal) {
            // Disable updates to system apps on sdcard
            res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION,
                    &quot;Cannot install updates to system apps on sdcard&quot;);
            return;
        }<br></div></div>

<p>This means that the system app cannot be installed to external storage.</p>
<p>Continue to analyze:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">// We are not on the mobile app, so don&apos;t go this branch
if (args.move != null) {
    // We did an in-place move, so dex is ready to roll
    scanFlags |= SCAN_NO_DEX;
    scanFlags |= SCAN_MOVE;

    synchronized (mPackages) {
        final PackageSetting ps = mSettings.mPackages.get(pkgName);
        if (ps == null) {
            res.setError(INSTALL_FAILED_INTERNAL_ERROR,
                    &quot;Missing settings for moved package &quot; + pkgName);
        }

        // We moved the entire application as-is, so bring over the
        // previously derived ABI information.
        pkg.applicationInfo.primaryCpuAbi = ps.primaryCpuAbiString;
        pkg.applicationInfo.secondaryCpuAbi = ps.secondaryCpuAbiString;
    }

} else if (!forwardLocked &amp;&amp; !pkg.applicationInfo.isExternalAsec()) {
  //Go this branch
    // Enable SCAN_NO_DEX flag to skip dexopt at a later stage
    // Set SCAN_NO_DEX so that dexopt will not be executed at this stage
    scanFlags |= SCAN_NO_DEX;

    Try {

        derivePackageAbi(pkg, new File(pkg.codePath), args.abiOverride,
                True /* extract libs */);
    } catch (PackageManagerException pme) {
        Slog.e (TAG, &quot;Error deriving application ABI&quot;, pme);
        res.setError(INSTALL_FAILED_INTERNAL_ERROR, &quot;Error deriving application ABI&quot;);
        Return;
    }

    // Run dexopt before old package gets removed, to minimize time when app is unavailable
    int result = mPackageDexOptimizer
            .performDexOpt(pkg, null /* instruction sets */, false /* forceDex */,
                    False /* defer */, false /* inclDependencies */);
    if (result == PackageDexOptimizer.DEX_OPT_FAILED) {
        res.setError(INSTALL_FAILED_DEXOPT, &quot;Dexopt failed for &quot; + pkg.codePath);
        Return;
    }
}<br></div></div>

<p>The derivePackageAbi() method is also very important. It mainly completes the so
library path setting of apk and the value of the primary and secondary abi.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">/**
 * Derive the ABI of a non-system package located at {@code scanFile}. This information
 * is derived purely on the basis of the contents of {@code scanFile} and
 * {@code cpuAbiOverride}.
 *
 * If {@code extractLibs} is true, native libraries are extracted from the app if required.
 */
public void derivePackageAbi(PackageParser.Package pkg, File scanFile,
                             String cpuAbiOverride, boolean extractLibs)
        Throws PackageManagerException {
    / / Here is the first call, mainly to determine the following three fields in the applicationInfo in pkg
    // nativeLibraryRootDir /data/app/vmdl&lt;return id&gt;.tmp/lib
    // nativeLibraryRootRequiresIsa is true, the third-party app installed by the user, this field is true, indicating that you need to prefix in lib/, such as arm, arm64, etc.
    // nativeLibraryDir :/data/app/vmdl&lt;callback id&gt;.tmp/lib/&lt;prefix&gt;

    setNativeLibraryPaths(pkg);

    // We would never need to extract libs for forward-locked and external packages,
    // since the container service will do it for us. We shouldn&apos;t attempt to
    // extract libs from system app when it was not updated.
    if (pkg.isForwardLocked() || isExternal(pkg) ||
        (isSystemApp(pkg) &amp;&amp; !pkg.isUpdatedSystemApp()) ) {
        extractLibs = false;
    }

    final String nativeLibraryRootStr = pkg.applicationInfo.nativeLibraryRootDir;
    // For a third-party app installed by the user, this flag is true, indicating that you want to add &quot;arm&quot; or &quot;arm64&quot; or &quot;x86&quot; after the nativeLibraryRootStr path.
    // This type of prefix, please refer to setNativeLibraryPaths() for specific reasons.
    final boolean useIsaSpecificSubdirs = pkg.applicationInfo.nativeLibraryRootRequiresIsa;

    NativeLibraryHelper.Handle handle = null;
    Try {
        Handle = NativeLibraryHelper.Handle.create(scanFile);
        // TODO(multiArch): This can be null for apps that didn&apos;t go through the
        // usual installation process. We can calculate it again, like we
        // do during install time.
        //
        // TODO(multiArch): Why do we need to rescan ASEC apps again ? It seems totally
        // unnecessary.
        final File nativeLibraryRoot = new File(nativeLibraryRootStr);

        // Null out the abis so that they can be recalculated.
        pkg.applicationInfo.primaryCpuAbi = null;
        pkg.applicationInfo.secondaryCpuAbi = null;
        if (isMultiArch(pkg.applicationInfo)) {
            // Warn if we&apos;ve set an abiOverride for multi-lib packages..
            // By definition, we need to copy both 32 and 64 bit libraries for
            // such packages.
            // cpuAbiOverride is not valid for apk with multiple so library folders
            if (pkg.cpuAbiOverride != null
                    &amp;&amp; !NativeLibraryHelper.CLEAR_ABI_OVERRIDE.equals(pkg.cpuAbiOverride)) {
                Slog.w(TAG, &quot;Ignoring abiOverride for multi arch application.&quot;);
            }

            int abi32 = PackageManager.NO_NATIVE_LIBRARIES;
            int abi64 = PackageManager.NO_NATIVE_LIBRARIES;
            if (Build.SUPPORTED_32_BIT_ABIS.length &gt; 0) {
                if (extractLibs) {
                  // Here again, if the so library timestamp in lib in apk does not change, it will not be copied, because it has been copied before.
                  // Only copy again when the so library changes
                    Abi32 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,
                            nativeLibraryRoot, Build.SUPPORTED_32_BIT_ABIS,
                            useIsaSpecificSubdirs);
                } else {
                    Abi32 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_32_BIT_ABIS);
                }
            }

            maybeThrowExceptionForMultiArchCopy(
                    &quot;Error unpackaging 32 bit native libs for multiarch app.&quot;, abi32);

            if (Build.SUPPORTED_64_BIT_ABIS.length &gt; 0) {
                if (extractLibs) {
                  // Here again, if the so library timestamp in lib in apk does not change, it will not be copied, because it has been copied before.
                  // Only copy again when the so library changes
                    Abi64 = NativeLibraryHelper.copyNativeBinariesForSupportedAbi(handle,
                            nativeLibraryRoot, Build.SUPPORTED_64_BIT_ABIS,
                            useIsaSpecificSubdirs);
                } else {
                    Abi64 = NativeLibraryHelper.findSupportedAbi(handle, Build.SUPPORTED_64_BIT_ABIS);
                }
            }

            maybeThrowExceptionForMultiArchCopy(
                    &quot;Error unpackaging 64 bit native libs for multiarch app.&quot;, abi64);

            if (abi64 &gt;= 0) {
                // If the so library supports 64-bit abi, and the system is also 64-bit, Message1
                // Set the main abi to the value of the abi64 index in the list of ro.product.cpu.abilist64
                pkg.applicationInfo.primaryCpuAbi = Build.SUPPORTED_64_BIT_ABIS[abi64];
            }

            if (abi32 &gt;= 0) {
                final String abi = Build.SUPPORTED_32_BIT_ABIS[abi32];
                if (abi64 &gt;= 0) {
                    // When the system is 64 bit. And apk contains a 64-bit library, and also contains a 32-bit library.
                    // Then set the secondary abi to the value of the abi32 index in the list of ro.product.cpu.abilist32
                    pkg.applicationInfo.secondaryCpuAbi = abi;
                } else {
                    // If the app has only 32-bit libraries, then put
                    // The main abi is set to the value of the abi32 index in the list of ro.product.cpu.abilist32
                    pkg.applicationInfo.primaryCpuAbi = abi;
                }
            }<br></div></div>

<p>Next, call the following code to perform the dexopt operation:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">// Run dexopt before old package gets removed, to minimize time when app is unavailable
int result = mPackageDexOptimizer
        .performDexOpt(pkg, null /* instruction sets */, false /* forceDex */,
                false /* defer */, false /* inclDependencies */);
if (result == PackageDexOptimizer.DEX_OPT_FAILED) {
    res.setError(INSTALL_FAILED_DEXOPT, &quot;Dexopt failed for &quot; + pkg.codePath);
    return;
}<br></div></div>

<p>code show as below:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">int performDexOpt(PackageParser.Package pkg, String[] instructionSets,
        boolean forceDex, boolean defer, boolean inclDependencies) {
    ArraySet&lt;String&gt; done;
    if (inclDependencies &amp;&amp; (pkg.usesLibraries != null || pkg.usesOptionalLibraries != null)) {
        done = new ArraySet&lt;String&gt;();
        done.add(pkg.packageName);
    } else {
      // Take this branch
        done = null;
    }
    synchronized (mPackageManagerService.mInstallLock) {
        final boolean useLock = mSystemReady;
        if (useLock) {
            mDexoptWakeLock.setWorkSource(new WorkSource(pkg.applicationInfo.uid));
            mDexoptWakeLock.acquire();
        }
        try {
            // -----------------Call the following method
            return performDexOptLI(pkg, instructionSets, forceDex, defer, done);
        } finally {
            if (useLock) {
                mDexoptWakeLock.release();
            }
        }
    }
}<br></div></div>

<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">Private int performDexOptLI(PackageParser.Package pkg, String[] targetInstructionSets,
          Boolean forceDex, boolean defer, ArraySet&lt;String&gt; done) {

      // The incoming targetInstructionSets is null
      / / So instructionSets is the primary and secondary abi values &#x200B;&#x200B;of pkg.applicationInfo
      / / If there is no so library, there is no primary and secondary abi, then the first value of the ro.product.cpu.abilist list, get isa
      final String[] instructionSets = targetInstructionSets != null ?
              targetInstructionSets : getAppDexInstructionSets(pkg.applicationInfo);

      // done is null. So skip
      if (done != null) {
          Done.add(pkg.packageName);
          if (pkg.usesLibraries != null) {
              performDexOptLibsLI(pkg.usesLibraries, instructionSets, forceDex, defer, done);
          }
          if (pkg.usesOptionalLibraries != null) {
              performDexOptLibsLI(pkg.usesOptionalLibraries, instructionSets, forceDex, defer,
                      Done);
          }
      }

      if ((pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_HAS_CODE) == 0) {
          Return DEX_OPT_SKIPPED;
      }

      final boolean vmSafeMode = (pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_VM_SAFE_MODE) != 0;
      final boolean debuggable = (pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0;

      final List&lt;String&gt; paths = pkg.getAllCodePathsExcludingResourceOnly();
      Boolean performedDexOpt = false;
      // There are three basic cases here:
      // 1.) we need to dexopt, either because we are forced or it is needed
      // 2.) we are deferring a needed dexopt
      // 3.) we are skipping an unneeded dexopt
      final String[] dexCodeInstructionSets = getDexCodeInstructionSets(instructionSets);
      For (String dexCodeInstructionSet : dexCodeInstructionSets) {
          if (!forceDex &amp;&amp; pkg.mDexOptPerformed.contains(dexCodeInstructionSet)) {
              Continue;
          }

          For (String path : paths) {
              final int dexoptNeeded;
              if (forceDex) {
                // is false, so don&apos;t go here
                  dexoptNeeded = DexFile.DEX2OAT_NEEDED;
              } else {
                  Try {
                    // Because it is installing apk, getDexOptNeeded returns DEX2OAT_NEEDED
                      dexoptNeeded = DexFile.getDexOptNeeded(path, pkg.packageName,
                              dexCodeInstructionSet, defer);
                  } catch (IOException ioe) {
                      Slog.w(TAG, &quot;IOException reading apk: &quot; + path, ioe);
                      Return DEX_OPT_FAILED;
                  }
              }

              if (!forceDex &amp;&amp; defer &amp;&amp; dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
                  // We&apos;re deciding to defer a needed dexopt. Don&apos;t bother dexopting for other
                  // paths and instruction sets. We&apos;ll deal with them all together when we process
                  // our list of deferred dexopts.
                  addPackageForDeferredDexopt(pkg);
                  Return DEX_OPT_DEFERRED;
              }

              if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
                  final String dexoptType;
                  String oatDir = null;
                  if (dexoptNeeded == DexFile.DEX2OAT_NEEDED) {
                      dexoptType = &quot;dex2oat&quot;;
                      Try {
                        / / Get the oat directory: /data/app/vmdl &lt;installation call id&gt;.tmp/oat
                          oatDir = createOatDirIfSupported(pkg, dexCodeInstructionSet);
                      } catch (IOException ioe) {
                          Slog.w(TAG, &quot;Unable to create oatDir for package: &quot; + pkg.packageName);
                          Return DEX_OPT_FAILED;
                      }
                  } else if (dexoptNeeded == DexFile.PATCHOAT_NEEDED) {
                      dexoptType = &quot;patchoat&quot;;
                  } else if (dexoptNeeded == DexFile.SELF_PATCHOAT_NEEDED) {
                      dexoptType = &quot;self patchoat&quot;;
                  } else {
                      Throw new IllegalStateException(&quot;Invalid dexopt needed: &quot; + dexoptNeeded);
                  }


                  // Start executing dex2oat
                  Log.i(TAG, &quot;Running dexopt (&quot; + dexoptType + &quot;) on: &quot; + path + &quot; pkg=&quot;
                          + pkg.applicationInfo.packageName + &quot; isa=&quot; + dexCodeInstructionSet
                          + &quot; vmSafeMode=&quot; + vmSafeMode + &quot; debuggable=&quot; + debuggable
                          + &quot; oatDir = &quot; + oatDir);
                  final int sharedGid = UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
                  final int ret = mPackageManagerService.mInstaller.dexopt(path, sharedGid,
                          !pkg.isForwardLocked(), pkg.packageName, dexCodeInstructionSet,
                          dexoptNeeded, vmSafeMode, debuggable, oatDir);

                  // Dex2oat might fail to compiler / verifier errors. We soldier on
                  // regardless, and attempt to interpret the app as a safety net.
                  if (ret == 0) {
                      performedDexOpt = true;
                  }
              }<br></div></div>

<p>Executing dexopt here is actually executing dex2oat, which is used to convert
the dex file in apk into an oat file. It&apos;s worth noting that the oat files
generated before Android 6.0 are all in</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;sh&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">/data/dalvik_cache/<br></div></div>

<p>In the folder, starting from Android 6.0, this folder only stores the oat file
of the built-in application of the system. The oat file of the app installed by
the user is in the end.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;sh&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">/data/app/Package names/oat/&lt;isa&gt;<br></div></div>

<p>Continue to analyze installPackageLI:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">if (!args.doRename(res.returnCode, pkg, oldCodePath)) {
            res.setError(INSTALL_FAILED_INSUFFICIENT_STORAGE, &quot;Failed rename&quot;);
            return;
        }<br></div></div>

<p>This code is very clear from the name: rename. Is going to</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;sh&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">/data/app/vmdl&lt;installation session id&gt;.tmp<br></div></div>

<p>Rename</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;sh&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">/data/app/Package names-suffix<br></div></div>

<p>Suffix is &#x200B;&#x200B;1,2.......</p>
<p>Also update the affected fields in pkg.</p>
<p>Continue to analyze installPackageLI:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">startIntentFilterVerifications(args.user.getIdentifier(), replace, pkg);

       if (replace) {
         // If it is an overlay installation, go here
           replacePackageLI(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user,
                   installerPackageName, volumeUuid, res);
       } else {
         // First time installation, go here
           installNewPackageLI(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES,
                   Args.user, installerPackageName, volumeUuid, res);
       }
       synchronized (mPackages) {
           final PackageSetting ps = mSettings.mPackages.get(pkgName);
           if (ps != null) {
               res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true);
           }
       }<br></div></div>

<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">private void installNewPackageLI(PackageParser.Package pkg, int parseFlags, int scanFlags,
        UserHandle user, String installerPackageName, String volumeUuid,
        PackageInstalledInfo res) {
    // Remember this for later, in case we need to rollback this install
    String pkgName = pkg.packageName;

    if (DEBUG_INSTALL) Slog.d(TAG, &quot;installNewPackageLI: &quot; + pkg);
    final boolean dataDirExists = Environment
            .getDataUserPackageDirectory(volumeUuid, UserHandle.USER_OWNER, pkgName).exists();
    synchronized(mPackages) {

        / / Determine whether it constitutes an upgrade relationship
        if (mSettings.mRenamedPackages.containsKey(pkgName)) {
            res.setError(INSTALL_FAILED_ALREADY_EXISTS, &quot;Attempt to re-install &quot; + pkgName
                    + &quot;with first uninstalling package running as &quot;
                    + mSettings.mRenamedPackages.get(pkgName));
            Return;
        }
        // See if it is already installed
        if (mPackages.containsKey(pkgName)) {
            // Don&apos;t allow installation over an existing package with the same name.
            res.setError(INSTALL_FAILED_ALREADY_EXISTS, &quot;Attempt to re-install &quot; + pkgName
                    + &quot; without first uninstalling.&quot;);
            Return;
        }
    }

    try {
      // Very familiar, here is the scanPackageLI
        PackageParser.Package newPackage = scanPackageLI(pkg, parseFlags, scanFlags,
                System.currentTimeMillis(), user);

        updateSettingsLI(newPackage, installerPackageName, volumeUuid, null, null, res, user);

        if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) {

            deletePackageLI(pkgName, UserHandle.ALL, false, null, null,
                    dataDirExists ? PackageManager.DELETE_KEEP_DATA : 0,
                            res.removedInfo, true);
        }

    } catch (PackageManagerException e) {
        res.setError(&quot;Package couldn&apos;t be installed in &quot; + pkg.codePath, e);
    }
}<br></div></div>

<p>The focus has returned to the scanPackageLI parameter for the Package
method. The method internally calls the scanPackageDirtyLI method, which was
explained in detail in the previous article. The value here is the code
associated with the user&apos;s installed app.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, int parseFlags,
            int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
        final File scanFile = new File(pkg.codePath);
         ........................
        if ((parseFlags&amp;PackageParser.PARSE_IS_SYSTEM) != 0) {
            pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
        } else {
            // Only allow system apps to be flagged as core apps.
            pkg.coreApp = false;
        }

       .........................................
        // Initialize package source and resource directories
        File destCodeFile = new File(pkg.applicationInfo.getCodePath());
        File destResourceFile = new File(pkg.applicationInfo.getResourcePath());

        SharedUserSetting suid = null;
        PackageSetting pkgSetting = null;
        .............................................
        //writer
        synchronized (mPackages) {
            if (pkg.mSharedUserId != null) {
              .................................
            }

            // Check if we are renaming from an original package name.
            PackageSetting origPackage = null;
            String realName = null;
            if (pkg.mOriginalPackages != null) {
              ...............................
            }

            ..................................
            // Very important, in this method, the UID is assigned to the apk
            // and record some information about the current user&apos;s package status file:
            // /data/system/users/userid/package-restrictions.xml
            // Not as good as the current app is hidden, or disabled, and which components of the current app are disabled.
            pkgSetting = mSettings.getPackageLPw(pkg, origPackage, realName, suid, destCodeFile,
                    destResourceFile, pkg.applicationInfo.nativeLibraryRootDir,
                    pkg.applicationInfo.primaryCpuAbi,
                    pkg.applicationInfo.secondaryCpuAbi,
                    pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags,
                    User, false);
            if (pkgSetting == null) {
                Throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE,
                        &quot;Creating application package &quot; + pkg.packageName + &quot; failed&quot;);
            }


          .................................
            pkg.applicationInfo.uid = pkgSetting.appId;
            pkg.mExtras = pkgSetting;
          .....................................
        / / Check whether the installed app conflicts with the components defined by the installed app
            if ((scanFlags &amp; SCAN_NEW_INSTALL) != 0) {
                final int N = pkg.providers.size();
                int i;
                For (i=0; i&lt;N; i++) {
                    PackageParser.Provider p = pkg.providers.get(i);
                    ...................................
                    }
                }
            }
            ....................................
        final String pkgName = pkg.packageName;

        final long scanFileTime = scanFile.lastModified();
        final boolean forceDex = (scanFlags &amp; SCAN_FORCE_DEX) != 0;
        / / Modify the process information, such as the name, etc.
        pkg.applicationInfo.processName = fixProcessName(
                pkg.applicationInfo.packageName,
                pkg.applicationInfo.processName,
                pkg.applicationInfo.uid);

        File dataPath;
        if (mPlatformPackage == pkg) {
          ....................................

        } else {
            // Start creating a data sandbox directory
            dataPath = Environment.getDataUserPackageDirectory(pkg.volumeUuid,
                    UserHandle.USER_OWNER, pkg.packageName);

            Boolean uidError = false;
            if (dataPath.exists()) {
              ..........................................
            } else {
              ...............
              / / Call the daemon installd to complete the actual creation work
              // installd install will create &quot;/data/data/package name&quot;, permission 751, default is for users with userid 0
              // It internally calls installd&apos;s createUserData to create a sandbox directory for each non-zero system user.
              // /data/user/userid/package name and set permission 751, chown is set to the owner of the user
                int ret = createDataDirsLI(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid,
                        pkg.applicationInfo.seinfo);
                if (ret &lt; 0) {
                    // Error from installer
                    Throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE,
                            &quot;Unable to create data dirs [errorCode=&quot; + ret + &quot;]&quot;);
                }

              ............................................
        }

        final String path = scanFile.getPath();
        final String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);

        if ((scanFlags &amp; SCAN_NEW_INSTALL) == 0) {
          ..........................................
        } else {
            if ((scanFlags &amp; SCAN_MOVE) != 0) {
              .....................................
            }

      .........................
        }

        / / Start to create a connection to the so library file
        if (DEBUG_INSTALL) Slog.i(TAG, &quot;Linking native library dir for &quot; + path);//======================<br></div></div>

<p>The important execution process from installPackageLI is shown below:</p>
<p>     <a href="media/6780c4633bb1306816c134bb653d234d.png" rel="grouped" title="http://7xj6ce.com1.z0.glb.clouddn.com/PMS-11.png" target="_self" class="fancybox">
       <img src="media/6780c4633bb1306816c134bb653d234d.png" alt="http://7xj6ce.com1.z0.glb.clouddn.com/PMS-11.png">
     </a></p>
<p>After executing installPackageLI, return to the processPendingInstall method as
follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">private void processPendingInstall(final InstallArgs args, final int currentStatus) {
       // Queue up an async operation since the package installation may take a little while.
       mHandler.post(new Runnable() {
           public void run() {
            ...........................
               if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
                    //Under normal circumstances, nothing will be done.
                   args.doPreInstall(res.returnCode);
                   synchronized (mInstallLock) {
                       installPackageLI(args, res);
                   }
                   // Delete the contents of /data/app/package name when the installation fails
                   args.doPostInstall(res.returnCode, res.uid);
               }
            .....................................
            /* Omit the code about cloud backup*/
            .....................................
               if (!doRestore) {
                   // No restore possible, or the Backup Manager was mysteriously not
                   // available -- just fire the post-install work request directly.
                   If (DEBUG_INSTALL) Log.v(TAG, &quot;No restore - queue post-install for &quot; + token);
                   Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0);
                   mHandler.sendMessage(msg);
               }
           }
       });
   }<br></div></div>


<p>The next step is to send a POST_INSTALL message. The processing of the message
is mainly to send the broadcast. After the application is installed, the other
applications in the system are notified to start processing. For example, the
icon of the app needs to be added in the launcher. After the broadcast is
finished, the installation is over, and finally the initial caller is returned
to the original caller through the initial installation.</p>
<p>The broadcast sent has</p>
<ol>
<li><p>android.intent.action.PACKAGE_ADDED</p>
</li>
<li><p>When overwriting the installation, you also need to send:
android.intent.extra.REPLACING</p>
</li>
</ol>
<p>code show as below:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,
        packageName, extras, null, null, firstUsers);

final boolean update = res.removedInfo.removedPackage != null;
if (update) {
    extras.putBoolean(Intent.EXTRA_REPLACING, true);
}
sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,
        packageName, extras, null, null, updateUsers);
if (update) {
    sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED,
            packageName, extras, null, null, updateUsers);
    sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED,
            null, null, packageName, null, updateUsers);
    ................<br></div></div>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="Android PMS - Android 6 PMS installation APK.html" class="navigation navigation-prev " aria-label="Previous page: Android PMS - Android 6 PMS installation APK">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="Android PMS - Android 6 PMS Uninstall APK.html" class="navigation navigation-next " aria-label="Next page: Android PMS - Android 6 PMS Uninstall APK">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Android PMS - Android 6 PMS installation APK next article","level":"1.5.9","depth":2,"next":{"title":"Android PMS - Android 6 PMS Uninstall APK","level":"1.5.10","depth":2,"path":"Android PMS - Android 6 PMS Uninstall APK.md","ref":"Android PMS - Android 6 PMS Uninstall APK.md","articles":[]},"previous":{"title":"Android PMS - Android 6 PMS installation APK","level":"1.5.8","depth":2,"path":"Android PMS - Android 6 PMS installation APK.md","ref":"Android PMS - Android 6 PMS installation APK.md","articles":[]},"dir":"ltr"},"config":{"plugins":["include-html","fancybox","anchor-navigation-ex-toc","ace","-lunr","-search","search-plus","hide-published-with","splitter","expandable-chapters-interactive","wide-page"],"root":"./docs","styles":{"website":"styles/website.css"},"pluginsConfig":{"fancybox":{"helpers":{"buttons":{}}},"ace":{},"splitter":{},"wide-page":{},"anchor-navigation-ex-toc":{"showLevel":true,"associatedWithSummary":true,"mode":"float","printLog":false,"multipleH1":true,"float":{"showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""},"pageTop":{"showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""}},"hide-published-with":{},"include-html":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"expandable-chapters-interactive":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"expandable-chapters":{},"search-plus":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"gitbook":"*"},"file":{"path":"Android PMS - Android 6 PMS installation APK next article.md","mtime":"2018-09-21T03:05:06.377Z","type":"markdown"},"gitbook":{"version":"3.3.6","time":"2023-12-10T09:35:29.798Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.mousewheel.pack.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.fancybox.pack.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.fancybox-buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-ace/ace/ace.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-ace/ace.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search-plus/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-hide-published-with/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-interactive/expandable-chapters.js"></script>
        
    
        
        <script src="gitbook/@gitbook-ng/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

