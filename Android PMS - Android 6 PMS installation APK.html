
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Android PMS - Android 6 PMS installation APK Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="@gitbook-ng/gitbook 3.3.6">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fancybox/jquery.fancybox.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fancybox/jquery.fancybox-buttons.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-anchor-navigation-ex-toc/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-ace/ace.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search-plus/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-interactive/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-wide-page/wide.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="styles/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="Android PMS - Android 6 PMS installation APK next article.html" />
    
    
    <link rel="prev" href="Android PMS - Android 6 PMS install APK prelude.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    Graphical Android
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="Graphical Android - Zygote, System Server startup analysis.html">
            
                <a href="Graphical Android - Zygote, System Server startup analysis.html">
            
                    
                    Graphical Android - Zygote, System Server startup analysis
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    Android Permissions
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="Android Permissions - Android Runtime Permission.html">
            
                <a href="Android Permissions - Android Runtime Permission.html">
            
                    
                    Android Permissions - Android Runtime Permission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="Android Permissions - Android grantRuntimePermission Detailed.html">
            
                <a href="Android Permissions - Android grantRuntimePermission Detailed.html">
            
                    
                    Android Permissions - Android grantRuntimePermission Detailed
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="Android Permissions - Android GrantPermissionsActivity Detailed.html">
            
                <a href="Android Permissions - Android GrantPermissionsActivity Detailed.html">
            
                    
                    Android Permissions - Android GrantPermissionsActivity Detailed
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="Android Permissions - AppOps control for Normal permission.html">
            
                <a href="Android Permissions - AppOps control for Normal permission.html">
            
                    
                    Android Permissions - AppOps control for Normal permission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="Android Permissions - Android native permission control process.html">
            
                <a href="Android Permissions - Android native permission control process.html">
            
                    
                    Android Permissions - Android native permission control process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="Android Permissions - The difference between setUidMode and setMode in AppOps.html">
            
                <a href="Android Permissions - The difference between setUidMode and setMode in AppOps.html">
            
                    
                    Android Permissions - The difference between setUidMode and setMode in AppOps
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="Android Permissions - Application permissions before android M and application permissions after M.html">
            
                <a href="Android Permissions - Application permissions before android M and application permissions after M.html">
            
                    
                    Android Permissions - Application permissions before android M and application permissions after M
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="Android Permissions - Provider permissions detailed.html">
            
                <a href="Android Permissions - Provider permissions detailed.html">
            
                    
                    Android Permissions - Provider permissions detailed
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    Android OTA
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="Android OTA - Android OTA upgrade principle and process analysis 1.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 1.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="Android OTA - Android OTA upgrade principle and process analysis 2.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 2.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="Android OTA - Android OTA upgrade principle and process analysis 3.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 3.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="Android OTA - Android OTA upgrade principle and process analysis 4.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 4.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 4
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="Android OTA - Android OTA upgrade principle and process analysis 5.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 5.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="Android OTA - Android OTA upgrade principle and process analysis 6.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 6.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.7" data-path="Android OTA - Android OTA upgrade principle and process analysis 7.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 7.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 7
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.8" data-path="Android OTA - Android OTA upgrade principle and process analysis 8.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 8.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 8
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.9" data-path="Android OTA - Android OTA upgrade principle and process analysis 9.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 9.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 9
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" >
            
                <span>
            
                    
                    Android Package Manager Service (PMS)
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="Android PMS - Explore the Android PMS service.html">
            
                <a href="Android PMS - Explore the Android PMS service.html">
            
                    
                    Android PMS - Explore the Android PMS service
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="Android PMS - Some rules of the PMS runtime.html">
            
                <a href="Android PMS - Some rules of the PMS runtime.html">
            
                    
                    Android PMS - Some rules of the PMS runtime
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="Android PMS - Android 6 PMS Analysis.html">
            
                <a href="Android PMS - Android 6 PMS Analysis.html">
            
                    
                    Android PMS - Android 6 PMS Analysis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="Android PMS - Android 6 PMS analysis article 1.html">
            
                <a href="Android PMS - Android 6 PMS analysis article 1.html">
            
                    
                    Android PMS - Android 6 PMS analysis article 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="Android PMS - Android 6 PMS analysis article 2.html">
            
                <a href="Android PMS - Android 6 PMS analysis article 2.html">
            
                    
                    Android PMS - Android 6 PMS analysis article 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.6" data-path="Android PMS - Android 6 PMS analysis of the next article.html">
            
                <a href="Android PMS - Android 6 PMS analysis of the next article.html">
            
                    
                    Android PMS - Android 6 PMS analysis of the next article
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.7" data-path="Android PMS - Android 6 PMS install APK prelude.html">
            
                <a href="Android PMS - Android 6 PMS install APK prelude.html">
            
                    
                    Android PMS - Android 6 PMS install APK prelude
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.5.8" data-path="Android PMS - Android 6 PMS installation APK.html">
            
                <a href="Android PMS - Android 6 PMS installation APK.html">
            
                    
                    Android PMS - Android 6 PMS installation APK
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.9" data-path="Android PMS - Android 6 PMS installation APK next article.html">
            
                <a href="Android PMS - Android 6 PMS installation APK next article.html">
            
                    
                    Android PMS - Android 6 PMS installation APK next article
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.10" data-path="Android PMS - Android 6 PMS Uninstall APK.html">
            
                <a href="Android PMS - Android 6 PMS Uninstall APK.html">
            
                    
                    Android PMS - Android 6 PMS Uninstall APK
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.11" data-path="Android PMS - Android 6 PMS daemon installd.html">
            
                <a href="Android PMS - Android 6 PMS daemon installd.html">
            
                    
                    Android PMS - Android 6 PMS daemon installd
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" >
            
                <span>
            
                    
                    Android AOSP
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="Android AOSP - Debugging AOSP Platform code with Android Studio - Java Debugger.html">
            
                <a href="Android AOSP - Debugging AOSP Platform code with Android Studio - Java Debugger.html">
            
                    
                    Android AOSP - Debugging AOSP Platform code with Android Studio - Java Debugger
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="Android AOSP - Modify applications and rebuild emulator image effectively.html">
            
                <a href="Android AOSP - Modify applications and rebuild emulator image effectively.html">
            
                    
                    Android AOSP - Modify applications and rebuild emulator image effectively
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" >
            
                <span>
            
                    
                    Android General
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="Android General - Reliable connection to AIDL IPC Service in Android.html">
            
                <a href="Android General - Reliable connection to AIDL IPC Service in Android.html">
            
                    
                    Android General - Reliable connection to AIDL IPC Service in Android
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" >
            
                <span>
            
                    
                    Android Binder
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" >
            
                <span>
            
                    
                    Android Activity Manager Service (AMS)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" >
            
                <span>
            
                    
                    Live555
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="Live555 - Live555 source code analysis_introduction.html">
            
                <a href="Live555 - Live555 source code analysis_introduction.html">
            
                    
                    Live555 - Live555 source code analysis_introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="Live555 - Live555 source code analysis_infrastructure.html">
            
                <a href="Live555 - Live555 source code analysis_infrastructure.html">
            
                    
                    Live555 - Live555 source code analysis_infrastructure
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="Live555 - Live555 source code analysis_mediaserver.html">
            
                <a href="Live555 - Live555 source code analysis_mediaserver.html">
            
                    
                    Live555 - Live555 source code analysis_mediaserver
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="Live555 - Wireshark capture packet analysis RTSP_RTP_RTCP basic working process.html">
            
                <a href="Live555 - Wireshark capture packet analysis RTSP_RTP_RTCP basic working process.html">
            
                    
                    Live555 - Wireshark capture packet analysis RTSP_RTP_RTCP basic working process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="Live555 - Live555 source code analysis_rtspserver.html">
            
                <a href="Live555 - Live555 source code analysis_rtspserver.html">
            
                    
                    Live555 - Live555 source code analysis_rtspserver
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.6" data-path="Live555 - Live555 source code analysis_describe processing.html">
            
                <a href="Live555 - Live555 source code analysis_describe processing.html">
            
                    
                    Live555 - Live555 source code analysis_describe processing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.7" data-path="Live555 - Live555 source code analysis_setup processing.html">
            
                <a href="Live555 - Live555 source code analysis_setup processing.html">
            
                    
                    Live555 - Live555 source code analysis_setup processing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.8" data-path="Live555 - Live555 source code analysis_play processing.html">
            
                <a href="Live555 - Live555 source code analysis_play processing.html">
            
                    
                    Live555 - Live555 source code analysis_play processing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.9" data-path="Live555 - Live555 source code analysis_RTSPServer component structure.html">
            
                <a href="Live555 - Live555 source code analysis_RTSPServer component structure.html">
            
                    
                    Live555 - Live555 source code analysis_RTSPServer component structure
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.10" data-path="Live555 - Live555 source code analysis_servermediasession.html">
            
                <a href="Live555 - Live555 source code analysis_servermediasession.html">
            
                    
                    Live555 - Live555 source code analysis_servermediasession
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.11" data-path="Live555 - Live555 source code analysis_subsession SDP line generation.html">
            
                <a href="Live555 - Live555 source code analysis_subsession SDP line generation.html">
            
                    
                    Live555 - Live555 source code analysis_subsession SDP line generation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.12" data-path="Live555 - Live555 source code analysis_Subsession SETUP.html">
            
                <a href="Live555 - Live555 source code analysis_Subsession SETUP.html">
            
                    
                    Live555 - Live555 source code analysis_Subsession SETUP
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.13" data-path="Live555 - Live555 source code analysis_play start.html">
            
                <a href="Live555 - Live555 source code analysis_play start.html">
            
                    
                    Live555 - Live555 source code analysis_play start
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11" >
            
                <span>
            
                    
                    Flutter
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="Flutter Framework Analysis 1 - Overview and Window.html">
            
                <a href="Flutter Framework Analysis 1 - Overview and Window.html">
            
                    
                    Flutter Framework Analysis 1 - Overview and Window
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="Flutter Framework Analysis 2 - Initialization.html">
            
                <a href="Flutter Framework Analysis 2 - Initialization.html">
            
                    
                    Flutter Framework Analysis 2 - Initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="Flutter Framework Analysis 3 - Widget, Element and RenderObject.html">
            
                <a href="Flutter Framework Analysis 3 - Widget, Element and RenderObject.html">
            
                    
                    Flutter Framework Analysis 3 - Widget, Element and RenderObject
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.4" data-path="Flutter Framework Analysis 4 - Flutter Framework Operation.html">
            
                <a href="Flutter Framework Analysis 4 - Flutter Framework Operation.html">
            
                    
                    Flutter Framework Analysis 4 - Flutter Framework Operation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.5" data-path="Flutter Framework Analysis 5 - Animation.html">
            
                <a href="Flutter Framework Analysis 5 - Animation.html">
            
                    
                    Flutter Framework Analysis 5 - Animation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.6" data-path="Flutter Framework Analysis 6 - Layout.html">
            
                <a href="Flutter Framework Analysis 6 - Layout.html">
            
                    
                    Flutter Framework Analysis 6 - Layout
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.7" data-path="Flutter Framework Analysis 7 - Drawing.html">
            
                <a href="Flutter Framework Analysis 7 - Drawing.html">
            
                    
                    Flutter Framework Analysis 7 - Drawing
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Android PMS - Android 6 PMS installation APK</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div class="search-plus" id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <div id="anchor-navigation-ex-navbar"><i class="fa fa-anchor"></i><ul><li><span class="title-icon "></span><a href="#android-6-pms-installation-apk"><b>1. </b>Android 6 PMS installation APK</a></li><ul><li><span class="title-icon "></span><a href="#permission-check"><b>1.1. </b>Permission check</a></li><li><span class="title-icon "></span><a href="#copy-file"><b>1.2. </b>Copy file</a></li></ul></ul></div><a href="#android-6-pms-installation-apk" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><h1 id="android-6-pms-installation-apk"><a name="android-6-pms-installation-apk" class="anchor-navigation-ex-anchor" href="#android-6-pms-installation-apk"><i class="fa fa-link" aria-hidden="true"></i></a>1. Android 6 PMS installation APK</h1>
<p><a href="http://www.iloveandroid.net/tags/Android%E6%A0%B8%E5%BF%83%E6%9C%8D%E5%8A%A1/" target="_blank">Android core service</a>
<a href="http://www.iloveandroid.net/categories/Android%E5%BA%95%E5%B1%82%E5%BC%80%E5%8F%91/" target="_blank">Android underlying development</a></p>
<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#android-6-pms-installation-apk"><strong>Android 6 PMS installation APK</strong></a><ul>
<li><a href="#permission-check"><strong>Permission check</strong></a></li>
<li><a href="#copy-file"><strong>Copy file</strong></a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<p>Now let&apos;s formally analyze how Android installs an APK.</p>
<p>When using an Intent to install an apk file in an Android store, it is actually
called by an internal application packageinstaller of the Android system. This
built-in system application will display the installation process, and naturally
there is an interface. Everyone should be very familiar with it. It is nothing
more than displaying some progress bars, what permissions this app has, and
whether it is open after installation.</p>
<p>The packageinstaller is also a call to the PMS. When installing, the PMS related
interface will be called first, and the APK file, that is, its
AndroidMainifest.xml file, will be parsed, so that the app components,
permissions, package names and other information are obtained. Then check the
app is installed by the package name key. If it is installed, set the flag of
replace:INSTALL_REPLACE_EXISTING.</p>
<p>If it has not been installed before, then an activity will pop up, showing what
permissions the app has. There are two Buttons at the bottom: &quot;Cancel&quot; and
&quot;Install&quot;. Click &quot;Install&quot; and it will start to install.</p>
<p>If the app has been installed before, the pop-up Activity will prompt: &quot;Do you
want to install a new version of this app?...&quot;, and finally list the new app
compared to the app already installed on the device. What changes have been made
to the permissions, such as which permissions have been added. Two buttons are
also provided at the bottom: &quot;Cancel&quot; and &quot;Install&quot;. Click &quot;Install&quot; and it will
start to install.</p>
<p>After clicking the &quot;Install&quot; button, it actually jumps to the InstallAppProgress
activity of the PackageInstaller.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">Android-6/frameworks/base/core/java/android/content/pm/InstallAppProgress.java<br></div></div>

<p>In fact, it is the onCreate method of the activity. The method calls the
initView method. The initView method performs a series of judgments again and
creates an observer class PackageInstallObserver object for observing whether
the installation is successful. Then, the following method is called to start
the real installation. process.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">pm.installPackageWithVerificationAndEncryption(mPackageURI, observer, installFlags,
        installerPackageName, verificationParams, null);<br></div></div>

<p>Its code is implemented:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;sh&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">Android6.0/frameworks/base/core/java/android/app/ApplicationPackageManager.java<br></div></div>

<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">public void installPackageWithVerificationAndEncryption(Uri packageURI,
        PackageInstallObserver observer, int flags, String installerPackageName,
        VerificationParams verificationParams, ContainerEncryptionParams encryptionParams) {
    installCommon(packageURI, observer, flags, installerPackageName, verificationParams,
            encryptionParams);
}<br></div></div>

<p>The installCommon method is called directly inside:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">private void installCommon(Uri packageURI,
           PackageInstallObserver observer, int flags, String installerPackageName,
           VerificationParams verificationParams, ContainerEncryptionParams encryptionParams) {
       if (!&quot;file&quot;.equals(packageURI.getScheme())) {
           throw new UnsupportedOperationException(&quot;Only file:// URIs are supported&quot;);
       }
       if (encryptionParams != null) {
           throw new UnsupportedOperationException(&quot;ContainerEncryptionParams not supported&quot;);
       }

       final String originPath = packageURI.getPath();
       try {
           mPM.installPackage(originPath, observer.getBinder(), flags, installerPackageName,
                   verificationParams, null);
       } catch (RemoteException ignored) {
       }
   }<br></div></div>

<p>After making a series of judgments, then call mPM&apos;s installPackage method. mPM
is a proxy for PMS. This means that the installPackage method of the PMS will
actually be called here:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">public void installPackage(String originPath, IPackageInstallObserver2 observer,
           int installFlags, String installerPackageName, VerificationParams verificationParams,
           String packageAbiOverride) {
       installPackageAsUser(originPath, observer, installFlags, installerPackageName,
               verificationParams, packageAbiOverride, UserHandle.getCallingUserId());
   }<br></div></div>

<p>The key point here is to remind that the last parameter packageAbiOverride is
passed in, meaning follow-up</p>
<p>The entire installation process is complex and can be roughly divided into two
processes:</p>
<ol>
<li><p>Permission check</p>
</li>
<li><p>Copy file</p>
</li>
<li><p>Loading application</p>
</li>
</ol>
<h2 id="permission-check"><a name="permission-check" class="anchor-navigation-ex-anchor" href="#permission-check"><i class="fa fa-link" aria-hidden="true"></i></a>1.1. Permission check</h2>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">public void installPackageAsUser(String originPath, IPackageInstallObserver2 observer,
           int installFlags, String installerPackageName, VerificationParams verificationParams,
           String packageAbiOverride, int userId) {
       mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INSTALL_PACKAGES, null);

       // Use the binder mechanism to get the uid final int of the installation process. callingUid = Binder.getCallingUid(); //        enforceCrossUserPermission(callingUid, userId, true , true , &quot;installPackageAsUser&quot; );




       ..............................................<br></div></div>

<p>Check permissions first:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">void enforceCrossUserPermission(int callingUid, int userId, boolean requireFullPermission,
            boolean checkShell, String message) {
        if (userId &lt; 0) {
            throw new IllegalArgumentException(&quot;Invalid userId &quot; + userId);
        }
        // The current userid and the userid of the initiator process are the same, then OK, return directly
        // We are in this situation now.
        if (userId == UserHandle.getUserId(callingUid)) return;

        //Inconsistent, it depends on whether the SYSTEM process is still not, then execute the logic, throw an exception
        if (callingUid != Process.SYSTEM_UID &amp;&amp; callingUid != 0) {
            if (requireFullPermission) {
                mContext.enforceCallingOrSelfPermission(
                        android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, message);
            } else {
                try {
                    mContext.enforceCallingOrSelfPermission(
                            android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, message);
                } catch (SecurityException se) {
                    mContext.enforceCallingOrSelfPermission(
                            android.Manifest.permission.INTERACT_ACROSS_USERS, message);
                }
            }
        }
    }<br></div></div>

<p>The permission check here is mainly to check if the process has permission to
install.</p>
<p>Continue with the installPackageAsUser code:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">//Check if the current system user has permission to install the app.
 if (isUserRestricted(userId, UserManager.DISALLOW_INSTALL_APPS)) {
     try {
         if (observer != null) {
             observer.onPackageInstalled(&quot;&quot;, INSTALL_FAILED_USER_RESTRICTED, null, null);
         }
     } catch (RemoteException re) {
     }
     return;
 }

 //If the originating process is shell or root, add flags:PackageManager.INSTALL_FROM_ADB
 if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID)) {
     installFlags |= PackageManager.INSTALL_FROM_ADB;

 } else {
     // Caller holds INSTALL_PACKAGES permission, so we&apos;re less strict
     // about installerPackageName.

     // Remove INSTALL_FROM_ADB and INSTALL_ALL_USERS from flags
     installFlags &amp;= ~PackageManager.INSTALL_FROM_ADB;
     installFlags &amp;= ~PackageManager.INSTALL_ALL_USERS;
 }

 //Create a current user&apos;s handle
 UserHandle user;
 if ((installFlags &amp; PackageManager.INSTALL_ALL_USERS) != 0) {
     user = UserHandle.ALL;
 } else {
     user = new UserHandle(userId);
 }

 // Only system components can circumvent runtime permissions when installing.
 // Android 6.0 When the permissions belong to the runtime permissions, a pop-up box is required to allow the user to authorize. For the system app, the runtime permission permission should be canceled, but the authorization is directly authorized.
 // Then add INSTALL_GRANT_RUNTIME_PERMISSIONS to the system app
 // We install a third-party app, of course there is no INSTALL_GRANT_RUNTIME_PERMISSIONS
 if ((installFlags &amp; PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0
         &amp;&amp; mContext.checkCallingOrSelfPermission(Manifest.permission
         .INSTALL_GRANT_RUNTIME_PERMISSIONS) == PackageManager.PERMISSION_DENIED) {
     throw new SecurityException(&quot;You need the &quot;
             + &quot;android.permission.INSTALL_GRANT_RUNTIME_PERMISSIONS permission &quot;
             + &quot;to use the PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS flag&quot;);
 }

 verificationParams.setInstallerUid(callingUid);<br></div></div>

<p>This is mainly to check whether the current user has permission to install the
app, and whether the installed app is installed only for the current user or for
all users. From the above code, it can be concluded that when the installation
process is shell or root, the flag contains INSTALL_ALL_USERS, it will be
installed for all users, otherwise in most cases, only the current user is
installed. When we use the pm command to install, we can choose which user to
install to, or all users, for this reason.</p>
<p>Continue with the installPackageAsUser code:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">final File originFile = new File(originPath);

//Subsequent judgments when the APK is installed, will be used
final OriginInfo origin = OriginInfo.fromUntrustedFile(originFile);

final Message msg = mHandler.obtainMessage(INIT_COPY);
msg.obj = new InstallParams(origin, null, observer, installFlags, installerPackageName,
        null, verificationParams, user, packageAbiOverride, null);
mHandler.sendMessage(msg);
}<br></div></div>

<p>Construct InstallParams, note that packageAbiOverride is null, and then use the
Handler mechanism in Android to send to the relevant thread to install.</p>
<p>The entire execution logic of installPackageAsUser is shown below.</p>
<p>     <a href="media/1af4f40683b75d496093535f54617c14.png" rel="grouped" title="http://7xj6ce.com1.z0.glb.clouddn.com/PMS-7.png" target="_self" class="fancybox">
       <img src="media/1af4f40683b75d496093535f54617c14.png" alt="http://7xj6ce.com1.z0.glb.clouddn.com/PMS-7.png">
     </a></p>
<h2 id="copy-file"><a name="copy-file" class="anchor-navigation-ex-anchor" href="#copy-file"><i class="fa fa-link" aria-hidden="true"></i></a>1.2. Copy file</h2>
<p>I sent the INIT_COPY message in front, now I see how to handle:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">void doHandleMessage(Message msg) {
            switch (msg.what) {
                case INIT_COPY: {
                    HandlerParams params = (HandlerParams) msg.obj;
                    int idx = mPendingInstalls.size();
                    if (DEBUG_INSTALL) Slog.i(TAG, &quot;init_copy idx=&quot; + idx + &quot;: &quot; + params);
                    // If a bind was already initiated we dont really
                    // need to do anything. The pending install
                    // will be processed later on.
                    if (!mBound) {
                        // If this is the only one pending we might
                        // have to bind to the service again.
                        // Will bind the DefaultContainerService service
                        if (!connectToService()) {
                            Slog.e(TAG, &quot;Failed to bind to media container service&quot;);
                            params.serviceError();//Connection service failed
                            return;
                        } else {
                            // Once we bind to the service, the first
                            // pending request will be processed.
                            // The connection is successful, save the installation information to mPendingInstalls
                            // Wait for the return message of the connection to be received before proceeding with the installation
                            mPendingInstalls.add(idx, params);
                        }
                    } else {
                        // Insert installation information
                        mPendingInstalls.add(idx, params);
                        // Already bound to the service. Just make
                        // sure we trigger off processing the first request.
                        if (idx == 0) {
                            //If there is only one entry in mPendingInstalls, then the MCS_BOUND message is sent immediately.
                            mHandler.sendEmptyMessage(MCS_BOUND);
                        }
                    }
                    break;
                }
                ........<br></div></div>

<p>The INCon_COPY message will be bound to the DefaultContainerService, because
this is an asynchronous procedure. The result of the binding to be waited is
returned by onServiceConnected(), so the installed parameter information is
placed in the mPendingInstalls list. Bind it up, don&apos;t bind it again now, the
installation information should also be placed in mPendingInstalls. If multiple
installation requests arrive at the same time, they can be queued through the
mPendingInstalls list. If there is only one item in the list, there is no more
installation request, so in this case, you need to immediately issue the
MCS_BOUND message and proceed to the next step.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">private boolean connectToService() {
            if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;Trying to bind to&quot; +
                    &quot; DefaultContainerService&quot;);
            Intent service = new Intent().setComponent(DEFAULT_CONTAINER_COMPONENT);
            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
            if (mContext.bindServiceAsUser(service, mDefContainerConn,
                    Context.BIND_AUTO_CREATE, UserHandle.OWNER)) {
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                mBound = true;
                return true;
            }
            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            return false;
        }

class DefaultContainerConnection implements ServiceConnection {
       public void onServiceConnected(ComponentName name, IBinder service) {
           if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;onServiceConnected&quot;);
           IMediaContainerService imcs =
               IMediaContainerService.Stub.asInterface(service);
           mHandler.sendMessage(mHandler.obtainMessage(MCS_BOUND, imcs));
       }

       public void onServiceDisconnected(ComponentName name) {
           if (DEBUG_SD_INSTALL) Log.i(TAG, &quot;onServiceDisconnected&quot;);
       }
   }<br></div></div>

<p>You can see that an IBinder is converted to an IMediaContainerService in
onServiceConnected when the binding is successful. This is a remote proxy object
created by the object reference of IMediaContainerService.Stub passed in by the
parameter in the onServiceConnected callback function. Later, the PMS service
accesses the DefaultContainerService service through the proxy object. It is an
application service.</p>
<p>The entire INIT_COPY logic is as </p>
<p>     <a href="media/c6ad59e05e3713b175a4d7e4ae9b4a15.png" rel="grouped" title="http://7xj6ce.com1.z0.glb.clouddn.com/PMS-8.png" target="_self" class="fancybox">
       <img src="media/c6ad59e05e3713b175a4d7e4ae9b4a15.png" alt="http://7xj6ce.com1.z0.glb.clouddn.com/PMS-8.png">
     </a></p>
<p>shown.</p>
<p>Next, analyze the MCS_BOUND message.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">case MCS_BOUND:  {
                    if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_bound&quot;);
                    if (msg.obj != null) {
                        mContainerService = (IMediaContainerService) msg.obj;
                    }
                    if (mContainerService == null) {
                        if (!mBound) {
                            // Something seriously wrong since we are not bound and we are not
                            // waiting for connection. Bail out.
                            Slog.e(TAG, &quot;Cannot bind to media container service&quot;);
                            for (HandlerParams params : mPendingInstalls) {
                                // Indicate service bind error
                                // The connection failed, and the caller was notified of the error through the ruined interface in the parameter.
                                params.serviceError();
                            }
                            mPendingInstalls.clear();
                        } else {
                            Slog.w(TAG, &quot;Waiting to connect to media container service&quot;);
                        }
                    } else if (mPendingInstalls.size() &gt; 0) {
                        HandlerParams params = mPendingInstalls.get(0);
                        if (params != null) {
                            if (params.startCopy()) {//==============Perform a copy operation
                                // We are done...  look for more work or to
                                // go idle.
                                if (DEBUG_SD_INSTALL) Log.i(TAG,
                                        &quot;Checking for more work or unbind...&quot;);
                                // Delete pending install
                                if (mPendingInstalls.size() &gt; 0) {
                                    mPendingInstalls.remove(0);//Delete the first item after the work is completed
                                }
                                if (mPendingInstalls.size() == 0) {
                                    if (mBound) {
                                        if (DEBUG_SD_INSTALL) Log.i(TAG,
                                                &quot;Posting delayed MCS_UNBIND&quot;);
                                        removeMessages(MCS_UNBIND);
                                        Message ubmsg = obtainMessage(MCS_UNBIND);
                                        // Unbind after a little delay, to avoid
                                        // continual thrashing.
                                        // If there is no installation information, send a MCS_UNBIND message with a delay of 10 seconds.
                                        sendMessageDelayed(ubmsg, 10000);
                                    }
                                } else {
                                    // There are more pending requests in queue.
                                    // Just post MCS_BOUND message to trigger processing
                                    // of next pending install.
                                    // If there is still installation information, continue to send MCS_BOUND message
                                    if (DEBUG_SD_INSTALL) Log.i(TAG,
                                            &quot;Posting MCS_BOUND for next work&quot;);
                                    mHandler.sendEmptyMessage(MCS_BOUND);
                                }
                            }
                        }
                    } else {
                        // Should never happen ideally.
                        Slog.w(TAG, &quot;Empty queue&quot;);
                    }
                    break;
                }<br></div></div>

<p>The processing of the MCS_BOUND message is to call the startCopy() method of the
InstallParams class to perform the copy operation. As long as there is
installation information in mPendingInstalls, the MCS_BOUND message will be sent
repeatedly until all applications are installed, and then a MCS_UNBIND message
with a delay of 10 seconds is sent.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">case MCS_UNBIND: {
                    // If there is no actual work left, then time to unbind.
                    if (DEBUG_INSTALL) Slog.i(TAG, &quot;mcs_unbind&quot;);

                    if (mPendingInstalls.size() == 0 &amp;&amp; mPendingVerification.size() == 0) {
                        if (mBound) {
                            if (DEBUG_INSTALL) Slog.i(TAG, &quot;calling disconnectService()&quot;);

                            disconnectService();
                        }
                    } else if (mPendingInstalls.size() &gt; 0) {
                        // There are more pending requests in queue.
                        // Just post MCS_BOUND message to trigger processing
                        // of next pending install.
                        mHandler.sendEmptyMessage(MCS_BOUND);
                    }

                    break;
                }<br></div></div>

<p>The processing of the MCS_UNBIND message is simple. When there is no
installation information in mPendingInstalls, the disconnectService is called to
disconnect from the DefaultContainerService. If there is still installation
information, continue to send the MCS_BOUND message.</p>
<p>Next, analyze the real copy method: startCopy</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">final boolean startCopy() {
           boolean res;
           try {
               if (DEBUG_INSTALL) Slog.i(TAG, &quot;startCopy &quot; + mUser + &quot;: &quot; + this);
              // MAX_RETRIES&#x4E3A;4
               if (++mRetries &gt; MAX_RETRIES) {
                   Slog.w(TAG, &quot;Failed to invoke remote methods on default container service. Giving up&quot;);
                   mHandler.sendEmptyMessage(MCS_GIVE_UP);
                   handleServiceError();
                   return false;
               } else {
                   handleStartCopy();
                   res = true;
               }
           } catch (RemoteException e) {
               if (DEBUG_INSTALL) Slog.i(TAG, &quot;Posting install MCS_RECONNECT&quot;);
               mHandler.sendEmptyMessage(MCS_RECONNECT);
               res = false;
           }
           handleReturnCode();//Will try to rebind
           return res;
       }<br></div></div>

<p>The startCopy() method does the copy operation by calling handleStartCopy() of
its subclass InstallParams. Considering the uncertainty of the installation
process, the main job of startCopy is to handle the error. When the exception
that runs out of the handleStartCopy is captured, startCopy will send
MCS_RECONNECT. In the processing of the MCS_RECONNECT message, the
DefaultContainerService will be re-bound, if the binding is successful. , then
the installation process will start over. startCopy will also be called again,
the number of retries is recorded in mRetries, and when the cumulative retry
exceeds 4 times, the installation will be lost. If the installation fails,
startCopy will call handleReturnCode() to continue processing.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">public void handleStartCopy() throws RemoteException{
           int ret = PackageManager.INSTALL_SUCCEEDED;

           // If we&apos;re already staged, we&apos;ve firmly committed to an install location
           // Here staged is false, the front is false when the origin is created.
           if (origin.staged) {
               if (origin.file != null) {
                   installFlags |= PackageManager.INSTALL_INTERNAL;
                   installFlags &amp;= ~PackageManager.INSTALL_EXTERNAL;
               } else if (origin.cid != null) {
                   installFlags |= PackageManager.INSTALL_EXTERNAL;
                   installFlags &amp;= ~PackageManager.INSTALL_INTERNAL;
               } else {
                   throw new IllegalStateException(&quot;Invalid stage location&quot;);
               }
           }

           // Check if there is a setting in installFlags where it is installed. In this case, we have not set it, but when installing through the pm command, it is possible to specify where to install it.
           final boolean onSd = (installFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0;
           final boolean onInt = (installFlags &amp; PackageManager.INSTALL_INTERNAL) != 0;

           //Lite PackageInfo
           PackageInfoLite pkgLite = null;

           // If the installation is set in the internal storage and the installation is installed in the external SD, an error is reported.
           if (onInt &amp;&amp; onSd) {
               // Check if both bits are set.
               Slog.w(TAG, &quot;Conflicting flags specified for installing on both internal and external&quot;);
               ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;
           } else {
               pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath, installFlags,
                       packageAbiOverride);

               /*
                * If we have too little free space, try to free cache
                * before giving up.
                */
                //Check if the storage space is enough to install the app. If not enough, execute the following branch.
               if (!origin.staged &amp;&amp; pkgLite.recommendedInstallLocation
                       == PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE) {
                   // TODO: focus freeing disk space on the target device
                   final StorageManager storage = StorageManager.from(mContext);
                   final long lowThreshold = storage.getStorageLowBytes(
                           Environment.getDataDirectory());

                   final long sizeBytes = mContainerService.calculateInstalledSize(
                           origin.resolvedPath, isForwardLocked(), packageAbiOverride);

                   //Try to free some cache space
                   if (mInstaller.freeCache(null, sizeBytes + lowThreshold) &gt;= 0) {
                     //Then re-acquire PackageInfoLite
                       pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath,
                               installFlags, packageAbiOverride);
                   }

                   /*
                    * The cache free must have deleted the file we
                    * downloaded to install.
                    *
                    * TODO: fix the &quot;freeCache&quot; call to not delete
                    *       the file we care about.
                    */
                   if (pkgLite.recommendedInstallLocation
                           == PackageHelper.RECOMMEND_FAILED_INVALID_URI) {
                       pkgLite.recommendedInstallLocation
                           = PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE;
                   }
               }
           }

           if (ret == PackageManager.INSTALL_SUCCEEDED) {
               int loc = pkgLite.recommendedInstallLocation;
               if (loc == PackageHelper.RECOMMEND_FAILED_INVALID_LOCATION) {
                   ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION;
               } else if (loc == PackageHelper.RECOMMEND_FAILED_ALREADY_EXISTS) {
                   ret = PackageManager.INSTALL_FAILED_ALREADY_EXISTS;
               } else if (loc == PackageHehandleStartCopylper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE) {
                   ret = PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
               } else if (loc == PackageHelper.RECOMMEND_FAILED_INVALID_APK) {
                   ret = PackageManager.INSTALL_FAILED_INVALID_APK;
               } else if (loc == PackageHelper.RECOMMEND_FAILED_INVALID_URI) {
                   ret = PackageManager.INSTALL_FAILED_INVALID_URI;
               } else if (loc == PackageHelper.RECOMMEND_MEDIA_UNAVAILABLE) {
                   ret = PackageManager.INSTALL_FAILED_MEDIA_UNAVAILABLE;
               } else {
                   // Override with defaults if needed.
                   loc = installLocationPolicy(pkgLite);
                   if (loc == PackageHelper.RECOMMEND_FAILED_VERSION_DOWNGRADE) {
                       ret = PackageManager.INSTALL_FAILED_VERSION_DOWNGRADE;
                   } else if (!onSd &amp;&amp; !onInt) {
                       // Override install location with flags
                       if (loc == PackageHelper.RECOMMEND_INSTALL_EXTERNAL) {
                           // Set the flag to install on external media.
                           installFlags |= PackageManager.INSTALL_EXTERNAL;
                           installFlags &amp;= ~PackageManager.INSTALL_INTERNAL;
                       } else {
                           // Make sure the flag for installing on external
                           // media is unset
                           installFlags |= PackageManager.INSTALL_INTERNAL;
                           installFlags &amp;= ~PackageManager.INSTALL_EXTERNAL;
                       }
                   }
               }
           }

           // Where abiOverride is null
           final InstallArgs args = createInstallArgs(this);
           mArgs = args;

           if (ret == PackageManager.INSTALL_SUCCEEDED) {
                /*
                * ADB installs appear as UserHandle.USER_ALL, and can only be performed by
                * UserHandle.USER_OWNER, so use the package verifier for UserHandle.USER_OWNER.
                */
               int userIdentifier = getUser().getIdentifier();
               if (userIdentifier == UserHandle.USER_ALL
                       &amp;&amp; ((installFlags &amp; PackageManager.INSTALL_FROM_ADB) != 0)) {
                   userIdentifier = UserHandle.USER_OWNER;
               }

               /*
                * Determine if we have any installed package verifiers. If we
                * do, then we&apos;ll defer to them to verify the packages.
                */
               final int requiredUid = mRequiredVerifierPackage == null ? -1
                       : getPackageUid(mRequiredVerifierPackage, userIdentifier);
               if (!origin.existing &amp;&amp; requiredUid != -1
                       &amp;&amp; isVerificationEnabled(userIdentifier, installFlags)) {
                   //Here is the check, the specific check does not go deep, because it sent this
                   //android.intent.action.PACKAGE_NEEDS_VERIFICATION
                   // I didn&apos;t find anyone to handle it.
                   ..................................
               } else {
                   /*
                    * No package verification is enabled, so immediately start
                    * the remote call to initiate copy using temporary file.
                    */
                   ret = args.copyApk(mContainerService, true);
               }
           }

           mRet = ret;
       }<br></div></div>

<p>The handleStartCopy() method will determine where the app should be installed.
If there is not enough space in the installation, try to clean up some cache
space and try the installation again. A lot of the code in this method is to
process some information by sending Intent
android.intent.action.PACKAGE_NEEDS_VERIFICATION to all in the system to receive
the Intent, but unfortunately, I did not find the Dongdong to handle this
Intent. If you don&apos;t need to verify, you can call InstallArgs&apos; copyApk() method
directly.</p>
<p>The overall logic of the method is as </p>
<p>     <a href="media/523393256483e1c9ef6c690f98875aaf.png" rel="grouped" title="http://7xj6ce.com1.z0.glb.clouddn.com/PMS-9.png" target="_self" class="fancybox">
       <img src="media/523393256483e1c9ef6c690f98875aaf.png" alt="http://7xj6ce.com1.z0.glb.clouddn.com/PMS-9.png">
     </a></p>
<p>shown.</p>
<p>Before analyzing copyApk, look at the relationship between InstallParams and
InstallArgs:</p>
<p>     <a href="media/3ee3bc887925d86b89d18998e819fc0a.png" rel="grouped" title="http://7xj6ce.com1.z0.glb.clouddn.com/PMS-10.png" target="_self" class="fancybox">
       <img src="media/3ee3bc887925d86b89d18998e819fc0a.png" alt="http://7xj6ce.com1.z0.glb.clouddn.com/PMS-10.png">
     </a></p>
<p>The params passed in by createInstallArgs, in this case InstallParams, have
determined where the installation is in its handleStartCopy().</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">private InstallArgs createInstallArgs(InstallParams params) {
      if (params.move != null) {
        // Mobile app
          return new MoveInstallArgs(params);
      } else if (installOnExternalAsec(params.installFlags) || params.isForwardLocked()) {
        // Installed on SD
          return new AsecInstallArgs(params);
      } else {
        // Installed in internal storage
          return new FileInstallArgs(params);
      }
  }<br></div></div>

<p>In this case, it is installed in the internal storage, so the FileInstallArgs is
created, then the copyApk is called, which is naturally FileInstallArgs.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">int copyApk(IMediaContainerService imcs, boolean temp) throws RemoteException {
          if (origin.staged) {
              if (DEBUG_INSTALL) Slog.d(TAG, origin.file + &quot; already staged; skipping copy&quot;);
              codeFile = origin.file;
              resourceFile = origin.file;
              return PackageManager.INSTALL_SUCCEEDED;
          }

          try {
              final File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid);
              codeFile = tempDir;
              resourceFile = tempDir;
          } catch (IOException e) {
              Slog.w(TAG, &quot;Failed to create copy file: &quot; + e);
              return PackageManager.INSTALL_FAILED_INSUFFICIENT_STORAGE;
          }
  ............<br></div></div>

<p>allocateStageDirLegacy:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">public File allocateStageDirLegacy(String volumeUuid) throws IOException {
        synchronized (mSessions) {
            try {
                // Assign the ID of this installation session
                final int sessionId = allocateSessionIdLocked();
                mLegacySessions.put(sessionId, true);
                // Get a staged folder for this installation, which will be renamed later
                final File stageDir = buildStageDir(volumeUuid, sessionId);
                prepareStageDir(stageDir);
                return stageDir;
            } catch (IllegalStateException e) {
                throw new IOException(e);
            }
        }
    }

    private File buildStageDir(String volumeUuid, int sessionId) {
          final File stagingDir = buildStagingDir(volumeUuid);
          return new File(stagingDir, &quot;vmdl&quot; + sessionId + &quot;.tmp&quot;);
      }

      private File buildStagingDir(String volumeUuid) {
              return Environment.getDataAppDirectory(volumeUuid);
          }
      // volumeUuid is generally null
      public static File getDataDirectory(String volumeUuid) {
          if (TextUtils.isEmpty(volumeUuid)) {
              return new File(&quot;/data&quot;);
          } else {
              return new File(&quot;/mnt/expand/&quot; + volumeUuid);
          }
      }


      public static File getDataAppDirectory(String volumeUuid) {
          return new File(getDataDirectory(volumeUuid), &quot;app&quot;);
      }<br></div></div>

<p>The path string is obtained after the buildStageDir method is executed:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;sh&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">/data/app/vmdl&lt;Callback ID&gt;.tmp<br></div></div>

<p>prepareStageDir will create this folder and set the 755 permission.</p>
<p>Continue to analyze copyApk:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">final IParcelFileDescriptorFactory target = new IParcelFileDescriptorFactory.Stub() {
               @Override
               public ParcelFileDescriptor open(String name, int mode) throws RemoteException {
                   if (!FileUtils.isValidExtFilename(name)) {
                       throw new IllegalArgumentException(&quot;Invalid filename: &quot; + name);
                   }
                   try {
                       final File file = new File(codeFile, name);
                       final FileDescriptor fd = Os.open(file.getAbsolutePath(),
                               O_RDWR | O_CREAT, 0644);
                       Os.chmod(file.getAbsolutePath(), 0644);
                       return new ParcelFileDescriptor(fd);
                   } catch (ErrnoException e) {
                       throw new RemoteException(&quot;Failed to open: &quot; + e.getMessage());
                   }
               }
           };

           int ret = PackageManager.INSTALL_SUCCEEDED;
           ret = imcs.copyPackage(origin.file.getAbsolutePath(), target);
           if (ret != PackageManager.INSTALL_SUCCEEDED) {
               Slog.e(TAG, &quot;Failed to copy package&quot;);
               return ret;
           }<br></div></div>

<p>Call the copyPackage method of DefaultContainerService to copy the apk to be
installed to the directory created earlier, and set the permission to 644. After
executing here, copy base.apk to</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;sh&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">/data/app/vmdl&lt;Callback ID&gt;.tmp<br></div></div>

<p>In, and set the permissions to 644.</p>
<p>Continue to analyze copyApk:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">final File libraryRoot = new File(codeFile, LIB_DIR_NAME);
           NativeLibraryHelper.Handle handle = null;
           try {
               handle = NativeLibraryHelper.Handle.create(codeFile);
               ret = NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libraryRoot,
                       abiOverride);
           } catch (IOException e) {
               Slog.e(TAG, &quot;Copying native libraries failed&quot;, e);
               ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
           } finally {
               IoUtils.closeQuietly(handle);
           }<br></div></div>

<p>After the execution is successful, the app&apos;s so will be copied to:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;sh&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">/data/app/vmdl&lt;Callback ID&gt;.tmp/lib/arm/<br></div></div>

<p>If it is x86, the arm is replaced with x86 and so on.</p>
<p>The emphasis here is that abiOverride is null.</p>
<p>You can use the following method to view the abi situation in the device:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;sh&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">root@hammerhead:/data/system # getprop | grep abi
[ro.product.cpu.abi]: [armeabi-v7a]
[ro.product.cpu.abi2]: [armeabi]
[ro.product.cpu.abilist]: [armeabi-v7a,armeabi]
[ro.product.cpu.abilist32]: [armeabi-v7a,armeabi]
[ro.product.cpu.abilist64]: []<br></div></div>

<p>As you can see from the results, the logic of our device does not support 64-bit
abi.copyNativeBinariesWithOverride is as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;java&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">public static int copyNativeBinariesWithOverride(Handle handle, File libraryRoot,
            String abiOverride) {
        try {

            // If there are folders such as armeabi, areabi-v7a, x86, etc. in the lib in apk,
            // Take this branch, ignore abiOverride at this time
            if (handle.multiArch) {
                // Warn if we&apos;ve set an abiOverride for multi-lib packages..
                // By definition, we need to copy both 32 and 64 bit libraries for
                // such packages.
                if (abiOverride != null &amp;&amp; !CLEAR_ABI_OVERRIDE.equals(abiOverride)) {
                    Slog.w(TAG, &quot;Ignoring abiOverride for multi arch application.&quot;);
                }

                int copyRet = PackageManager.NO_NATIVE_LIBRARIES;
                if (Build.SUPPORTED_32_BIT_ABIS.length &gt; 0) {

                    // Because there are multiple so library folders, so choose to use the so library in the appropriate folder.
                    // The method is to obtain the abi in the list of ro.product.cpu.abilist32, and then compare the names of the so library folders, and find the matching folder.
                    // Copy the so library in the folder /data/app/vmdl.&lt;install callback id&gt;.tmp/lib/arm/, and match the folder name at
                    //Index return in ro.product.cpu.abilist32 list
                    copyRet = copyNativeBinariesForSupportedAbi(handle, libraryRoot,
                            Build.SUPPORTED_32_BIT_ABIS, true /* use isa specific subdirs */);
                    if (copyRet &lt; 0 &amp;&amp; copyRet != PackageManager.NO_NATIVE_LIBRARIES &amp;&amp;
                            copyRet != PackageManager.INSTALL_FAILED_NO_MATCHING_ABIS) {
                        Slog.w(TAG, &quot;Failure copying 32 bit native libraries; copyRet=&quot; +copyRet);
                        return copyRet;
                    }
                }

                if (Build.SUPPORTED_64_BIT_ABIS.length &gt; 0) {
                  // If the device supports 64-bit abi, then also get the abi in the list of ro.product.cpu.abilist64, and then compare the names of the so-li folder with the names of the so-li folder, and find the matching folder.
                  // Copy the so library in the folder /data/app/vmdl.&lt;installation id&gt;.tmp/lib/arm64/, and match the folder name at
                  // Index return in ro.product.cpu.abilist64 list
                    copyRet = copyNativeBinariesForSupportedAbi(handle, libraryRoot,
                            Build.SUPPORTED_64_BIT_ABIS, true /* use isa specific subdirs */);
                    if (copyRet &lt; 0 &amp;&amp; copyRet != PackageManager.NO_NATIVE_LIBRARIES &amp;&amp;
                            copyRet != PackageManager.INSTALL_FAILED_NO_MATCHING_ABIS) {
                        Slog.w(TAG, &quot;Failure copying 64 bit native libraries; copyRet=&quot; +copyRet);
                        return copyRet;
                    }
                }
            } else {
              // If there is only one so library folder in the lib folder in apk, then take this branch
                String cpuAbiOverride = null;
                if (CLEAR_ABI_OVERRIDE.equals(abiOverride)) {
                    cpuAbiOverride = null;
                } else if (abiOverride != null) {
                    cpuAbiOverride = abiOverride;
                }

                // Because the incoming cpuAbiOverride is null, so
                // abiList is the value in the list of ro.product.cpu.abilist
                String[] abiList = (cpuAbiOverride != null) ?
                        new String[] { cpuAbiOverride } : Build.SUPPORTED_ABIS;
                if (Build.SUPPORTED_64_BIT_ABIS.length &gt; 0 &amp;&amp; cpuAbiOverride == null &amp;&amp;
                        hasRenderscriptBitcode(handle)) {
                    abiList = Build.SUPPORTED_32_BIT_ABIS;
                }

                // Similarly, the abi value in the abiList is matched with the folder name of the so library in turn, and if it matches, the index of the matching abi in the abiList is returned.
                // And copy the so library to /data/app/vmdl.&lt;installation call id&gt;.tmp/lib/XXisaXX/
                // Xxisaxx can be arm arm64 x86, etc., depending on the value of abi
                int copyRet = copyNativeBinariesForSupportedAbi(handle, libraryRoot, abiList,
                        true /* use isa specific subdirs */);
                if (copyRet &lt; 0 &amp;&amp; copyRet != PackageManager.NO_NATIVE_LIBRARIES) {
                    Slog.w(TAG, &quot;Failure copying native libraries [errorCode=&quot; + copyRet + &quot;]&quot;);
                    return copyRet;
                }
            }

            return PackageManager.INSTALL_SUCCEEDED;
        } catch (IOException e) {
            Slog.e(TAG, &quot;Copying native libraries failed&quot;, e);
            return PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
        }
    }<br></div></div>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="Android PMS - Android 6 PMS install APK prelude.html" class="navigation navigation-prev " aria-label="Previous page: Android PMS - Android 6 PMS install APK prelude">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="Android PMS - Android 6 PMS installation APK next article.html" class="navigation navigation-next " aria-label="Next page: Android PMS - Android 6 PMS installation APK next article">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Android PMS - Android 6 PMS installation APK","level":"1.5.8","depth":2,"next":{"title":"Android PMS - Android 6 PMS installation APK next article","level":"1.5.9","depth":2,"path":"Android PMS - Android 6 PMS installation APK next article.md","ref":"Android PMS - Android 6 PMS installation APK next article.md","articles":[]},"previous":{"title":"Android PMS - Android 6 PMS install APK prelude","level":"1.5.7","depth":2,"path":"Android PMS - Android 6 PMS install APK prelude.md","ref":"Android PMS - Android 6 PMS install APK prelude.md","articles":[]},"dir":"ltr"},"config":{"plugins":["include-html","fancybox","anchor-navigation-ex-toc","ace","-lunr","-search","search-plus","hide-published-with","splitter","expandable-chapters-interactive","wide-page"],"root":"./docs","styles":{"website":"styles/website.css"},"pluginsConfig":{"fancybox":{"helpers":{"buttons":{}}},"ace":{},"splitter":{},"wide-page":{},"anchor-navigation-ex-toc":{"showLevel":true,"associatedWithSummary":true,"mode":"float","printLog":false,"multipleH1":true,"float":{"showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""},"pageTop":{"showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""}},"hide-published-with":{},"include-html":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"expandable-chapters-interactive":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"expandable-chapters":{},"search-plus":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"gitbook":"*"},"file":{"path":"Android PMS - Android 6 PMS installation APK.md","mtime":"2018-09-21T02:44:28.262Z","type":"markdown"},"gitbook":{"version":"3.3.6","time":"2023-12-10T09:35:29.798Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.mousewheel.pack.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.fancybox.pack.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.fancybox-buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-ace/ace/ace.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-ace/ace.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search-plus/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-hide-published-with/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-interactive/expandable-chapters.js"></script>
        
    
        
        <script src="gitbook/@gitbook-ng/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

