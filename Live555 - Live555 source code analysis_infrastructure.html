
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Live555 - Live555 source code analysis_infrastructure Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="@gitbook-ng/gitbook 3.3.6">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fancybox/jquery.fancybox.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fancybox/jquery.fancybox-buttons.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-anchor-navigation-ex-toc/style/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-ace/ace.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search-plus/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-interactive/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-wide-page/wide.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="styles/website.css">
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="Live555 - Live555 source code analysis_mediaserver.html" />
    
    
    <link rel="prev" href="Live555 - Live555 source code analysis_introduction.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    Graphical Android
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="Graphical Android - Zygote, System Server startup analysis.html">
            
                <a href="Graphical Android - Zygote, System Server startup analysis.html">
            
                    
                    Graphical Android - Zygote, System Server startup analysis
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    Android Permissions
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="Android Permissions - Android Runtime Permission.html">
            
                <a href="Android Permissions - Android Runtime Permission.html">
            
                    
                    Android Permissions - Android Runtime Permission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="Android Permissions - Android grantRuntimePermission Detailed.html">
            
                <a href="Android Permissions - Android grantRuntimePermission Detailed.html">
            
                    
                    Android Permissions - Android grantRuntimePermission Detailed
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="Android Permissions - Android GrantPermissionsActivity Detailed.html">
            
                <a href="Android Permissions - Android GrantPermissionsActivity Detailed.html">
            
                    
                    Android Permissions - Android GrantPermissionsActivity Detailed
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="Android Permissions - AppOps control for Normal permission.html">
            
                <a href="Android Permissions - AppOps control for Normal permission.html">
            
                    
                    Android Permissions - AppOps control for Normal permission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="Android Permissions - Android native permission control process.html">
            
                <a href="Android Permissions - Android native permission control process.html">
            
                    
                    Android Permissions - Android native permission control process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="Android Permissions - The difference between setUidMode and setMode in AppOps.html">
            
                <a href="Android Permissions - The difference between setUidMode and setMode in AppOps.html">
            
                    
                    Android Permissions - The difference between setUidMode and setMode in AppOps
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="Android Permissions - Application permissions before android M and application permissions after M.html">
            
                <a href="Android Permissions - Application permissions before android M and application permissions after M.html">
            
                    
                    Android Permissions - Application permissions before android M and application permissions after M
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="Android Permissions - Provider permissions detailed.html">
            
                <a href="Android Permissions - Provider permissions detailed.html">
            
                    
                    Android Permissions - Provider permissions detailed
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    Android OTA
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="Android OTA - Android OTA upgrade principle and process analysis 1.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 1.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="Android OTA - Android OTA upgrade principle and process analysis 2.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 2.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="Android OTA - Android OTA upgrade principle and process analysis 3.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 3.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="Android OTA - Android OTA upgrade principle and process analysis 4.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 4.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 4
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="Android OTA - Android OTA upgrade principle and process analysis 5.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 5.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="Android OTA - Android OTA upgrade principle and process analysis 6.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 6.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.7" data-path="Android OTA - Android OTA upgrade principle and process analysis 7.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 7.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 7
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.8" data-path="Android OTA - Android OTA upgrade principle and process analysis 8.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 8.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 8
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.9" data-path="Android OTA - Android OTA upgrade principle and process analysis 9.html">
            
                <a href="Android OTA - Android OTA upgrade principle and process analysis 9.html">
            
                    
                    Android OTA - Android OTA upgrade principle and process analysis 9
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" >
            
                <span>
            
                    
                    Android Package Manager Service (PMS)
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="Android PMS - Explore the Android PMS service.html">
            
                <a href="Android PMS - Explore the Android PMS service.html">
            
                    
                    Android PMS - Explore the Android PMS service
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="Android PMS - Some rules of the PMS runtime.html">
            
                <a href="Android PMS - Some rules of the PMS runtime.html">
            
                    
                    Android PMS - Some rules of the PMS runtime
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="Android PMS - Android 6 PMS Analysis.html">
            
                <a href="Android PMS - Android 6 PMS Analysis.html">
            
                    
                    Android PMS - Android 6 PMS Analysis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="Android PMS - Android 6 PMS analysis article 1.html">
            
                <a href="Android PMS - Android 6 PMS analysis article 1.html">
            
                    
                    Android PMS - Android 6 PMS analysis article 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="Android PMS - Android 6 PMS analysis article 2.html">
            
                <a href="Android PMS - Android 6 PMS analysis article 2.html">
            
                    
                    Android PMS - Android 6 PMS analysis article 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.6" data-path="Android PMS - Android 6 PMS analysis of the next article.html">
            
                <a href="Android PMS - Android 6 PMS analysis of the next article.html">
            
                    
                    Android PMS - Android 6 PMS analysis of the next article
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.7" data-path="Android PMS - Android 6 PMS install APK prelude.html">
            
                <a href="Android PMS - Android 6 PMS install APK prelude.html">
            
                    
                    Android PMS - Android 6 PMS install APK prelude
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.8" data-path="Android PMS - Android 6 PMS installation APK.html">
            
                <a href="Android PMS - Android 6 PMS installation APK.html">
            
                    
                    Android PMS - Android 6 PMS installation APK
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.9" data-path="Android PMS - Android 6 PMS installation APK next article.html">
            
                <a href="Android PMS - Android 6 PMS installation APK next article.html">
            
                    
                    Android PMS - Android 6 PMS installation APK next article
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.10" data-path="Android PMS - Android 6 PMS Uninstall APK.html">
            
                <a href="Android PMS - Android 6 PMS Uninstall APK.html">
            
                    
                    Android PMS - Android 6 PMS Uninstall APK
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.11" data-path="Android PMS - Android 6 PMS daemon installd.html">
            
                <a href="Android PMS - Android 6 PMS daemon installd.html">
            
                    
                    Android PMS - Android 6 PMS daemon installd
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" >
            
                <span>
            
                    
                    Android AOSP
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="Android AOSP - Debugging AOSP Platform code with Android Studio - Java Debugger.html">
            
                <a href="Android AOSP - Debugging AOSP Platform code with Android Studio - Java Debugger.html">
            
                    
                    Android AOSP - Debugging AOSP Platform code with Android Studio - Java Debugger
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="Android AOSP - Modify applications and rebuild emulator image effectively.html">
            
                <a href="Android AOSP - Modify applications and rebuild emulator image effectively.html">
            
                    
                    Android AOSP - Modify applications and rebuild emulator image effectively
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" >
            
                <span>
            
                    
                    Android General
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="Android General - Reliable connection to AIDL IPC Service in Android.html">
            
                <a href="Android General - Reliable connection to AIDL IPC Service in Android.html">
            
                    
                    Android General - Reliable connection to AIDL IPC Service in Android
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" >
            
                <span>
            
                    
                    Android Binder
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" >
            
                <span>
            
                    
                    Android Activity Manager Service (AMS)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" >
            
                <span>
            
                    
                    Live555
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="Live555 - Live555 source code analysis_introduction.html">
            
                <a href="Live555 - Live555 source code analysis_introduction.html">
            
                    
                    Live555 - Live555 source code analysis_introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.10.2" data-path="Live555 - Live555 source code analysis_infrastructure.html">
            
                <a href="Live555 - Live555 source code analysis_infrastructure.html">
            
                    
                    Live555 - Live555 source code analysis_infrastructure
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="Live555 - Live555 source code analysis_mediaserver.html">
            
                <a href="Live555 - Live555 source code analysis_mediaserver.html">
            
                    
                    Live555 - Live555 source code analysis_mediaserver
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="Live555 - Wireshark capture packet analysis RTSP_RTP_RTCP basic working process.html">
            
                <a href="Live555 - Wireshark capture packet analysis RTSP_RTP_RTCP basic working process.html">
            
                    
                    Live555 - Wireshark capture packet analysis RTSP_RTP_RTCP basic working process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="Live555 - Live555 source code analysis_rtspserver.html">
            
                <a href="Live555 - Live555 source code analysis_rtspserver.html">
            
                    
                    Live555 - Live555 source code analysis_rtspserver
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.6" data-path="Live555 - Live555 source code analysis_describe processing.html">
            
                <a href="Live555 - Live555 source code analysis_describe processing.html">
            
                    
                    Live555 - Live555 source code analysis_describe processing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.7" data-path="Live555 - Live555 source code analysis_setup processing.html">
            
                <a href="Live555 - Live555 source code analysis_setup processing.html">
            
                    
                    Live555 - Live555 source code analysis_setup processing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.8" data-path="Live555 - Live555 source code analysis_play processing.html">
            
                <a href="Live555 - Live555 source code analysis_play processing.html">
            
                    
                    Live555 - Live555 source code analysis_play processing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.9" data-path="Live555 - Live555 source code analysis_RTSPServer component structure.html">
            
                <a href="Live555 - Live555 source code analysis_RTSPServer component structure.html">
            
                    
                    Live555 - Live555 source code analysis_RTSPServer component structure
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.10" data-path="Live555 - Live555 source code analysis_servermediasession.html">
            
                <a href="Live555 - Live555 source code analysis_servermediasession.html">
            
                    
                    Live555 - Live555 source code analysis_servermediasession
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.11" data-path="Live555 - Live555 source code analysis_subsession SDP line generation.html">
            
                <a href="Live555 - Live555 source code analysis_subsession SDP line generation.html">
            
                    
                    Live555 - Live555 source code analysis_subsession SDP line generation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.12" data-path="Live555 - Live555 source code analysis_Subsession SETUP.html">
            
                <a href="Live555 - Live555 source code analysis_Subsession SETUP.html">
            
                    
                    Live555 - Live555 source code analysis_Subsession SETUP
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.13" data-path="Live555 - Live555 source code analysis_play start.html">
            
                <a href="Live555 - Live555 source code analysis_play start.html">
            
                    
                    Live555 - Live555 source code analysis_play start
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11" >
            
                <span>
            
                    
                    Flutter
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.11.1" data-path="Flutter Framework Analysis 1 - Overview and Window.html">
            
                <a href="Flutter Framework Analysis 1 - Overview and Window.html">
            
                    
                    Flutter Framework Analysis 1 - Overview and Window
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.2" data-path="Flutter Framework Analysis 2 - Initialization.html">
            
                <a href="Flutter Framework Analysis 2 - Initialization.html">
            
                    
                    Flutter Framework Analysis 2 - Initialization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.3" data-path="Flutter Framework Analysis 3 - Widget, Element and RenderObject.html">
            
                <a href="Flutter Framework Analysis 3 - Widget, Element and RenderObject.html">
            
                    
                    Flutter Framework Analysis 3 - Widget, Element and RenderObject
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.4" data-path="Flutter Framework Analysis 4 - Flutter Framework Operation.html">
            
                <a href="Flutter Framework Analysis 4 - Flutter Framework Operation.html">
            
                    
                    Flutter Framework Analysis 4 - Flutter Framework Operation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.5" data-path="Flutter Framework Analysis 5 - Animation.html">
            
                <a href="Flutter Framework Analysis 5 - Animation.html">
            
                    
                    Flutter Framework Analysis 5 - Animation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.6" data-path="Flutter Framework Analysis 6 - Layout.html">
            
                <a href="Flutter Framework Analysis 6 - Layout.html">
            
                    
                    Flutter Framework Analysis 6 - Layout
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11.7" data-path="Flutter Framework Analysis 7 - Drawing.html">
            
                <a href="Flutter Framework Analysis 7 - Drawing.html">
            
                    
                    Flutter Framework Analysis 7 - Drawing
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Live555 - Live555 source code analysis_infrastructure</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div class="search-plus" id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <div id="anchor-navigation-ex-navbar"><i class="fa fa-anchor"></i><ul><li><span class="title-icon "></span><a href="#live555-source-code-analysis-infrastructure"><b>1. </b>Live555 Source code analysis: Infrastructure</a></li><ul><li><span class="title-icon "></span><a href="#hashtable"><b>1.1. </b>HashTable</a></li><li><span class="title-icon "></span><a href="#usageenvironment--hashtable"><b>1.2. </b>UsageEnvironment : HashTable</a></li><li><span class="title-icon "></span><a href="#basicusageenvironment-&#x7684;-basichashtable"><b>1.3. </b>BasicUsageEnvironment &#x7684; BasicHashTable</a></li><li><span class="title-icon "></span><a href="#insert-an-element-into-the-basichashtable"><b>1.4. </b>Insert an element into the BasicHashTable</a></li><li><span class="title-icon "></span><a href="#find-elements-in-the-basichashtable"><b>1.5. </b>Find elements in the BasicHashTable</a></li><li><span class="title-icon "></span><a href="#remove-elements-from-basichashtable"><b>1.6. </b>Remove elements from BasicHashTable</a></li><li><span class="title-icon "></span><a href="#traversing-the-basichashtable-through-iterator"><b>1.7. </b>Traversing the BasicHashTable through Iterator</a></li><li><span class="title-icon "></span><a href="#usageenvironment"><b>1.8. </b>UsageEnvironment</a></li><li><span class="title-icon "></span><a href="#taskscheduler"><b>1.9. </b>TaskScheduler</a></li><li><span class="title-icon "></span><a href="#representation-of-time"><b>1.10. </b>Representation of time</a></li><li><span class="title-icon "></span><a href="#deferred-task-representation-and-organization"><b>1.11. </b>Deferred task representation and organization</a></li><li><span class="title-icon "></span><a href="#delayed-task-scheduling"><b>1.12. </b>Delayed task scheduling</a></li><li><span class="title-icon "></span><a href="#user-event-task-scheduling"><b>1.13. </b>User event task scheduling</a></li><li><span class="title-icon "></span><a href="#event-loop-execution-framework"><b>1.14. </b>Event loop execution framework</a></li><li><span class="title-icon "></span><a href="#socket-io-event-description-and-its-organization"><b>1.15. </b>Socket I/O event description and its organization</a></li><li><span class="title-icon "></span><a href="#socket-io-event-processing-task-scheduling"><b>1.16. </b>Socket I/O event processing task scheduling</a></li><li><span class="title-icon "></span><a href="#live555-source-code-analysis-series"><b>1.17. </b>Live555 source code analysis series</a></li></ul></ul></div><a href="#live555-source-code-analysis-infrastructure" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><h1 id="live555-source-code-analysis-infrastructure"><a name="live555-source-code-analysis-infrastructure" class="anchor-navigation-ex-anchor" href="#live555-source-code-analysis-infrastructure"><i class="fa fa-link" aria-hidden="true"></i></a>1. Live555 Source code analysis: Infrastructure</h1>
<p> Posted
on 2017-08-30 |  In <a href="https://www.wolfcstech.com/categories/live555/" target="_blank">live555</a> </p>
<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:0 orderedList:0 -->
<ul>
<li><a href="#live555-source-code-analysis-infrastructure"><strong>Live555 Source code analysis: Infrastructure</strong></a><ul>
<li><a href="#hashtable"><strong>HashTable</strong></a></li>
<li><a href="#usageenvironment-hashtable"><strong>UsageEnvironment : HashTable</strong></a></li>
<li><a href="#basicusageenvironment-&#x7684;-basichashtable"><strong>BasicUsageEnvironment &#x7684; BasicHashTable</strong></a></li>
<li><a href="#insert-an-element-into-the-basichashtable"><strong>Insert an element into the BasicHashTable</strong></a></li>
<li><a href="#find-elements-in-the-basichashtable"><strong>Find elements in the BasicHashTable</strong></a></li>
<li><a href="#remove-elements-from-basichashtable"><strong>Remove elements from BasicHashTable</strong></a></li>
<li><a href="#traversing-the-basichashtable-through-iterator"><strong>Traversing the BasicHashTable through Iterator</strong></a></li>
<li><a href="#usageenvironment"><strong>UsageEnvironment</strong></a></li>
<li><a href="#taskscheduler"><strong>TaskScheduler</strong></a></li>
<li><a href="#representation-of-time"><strong>Representation of time</strong></a></li>
<li><a href="#deferred-task-representation-and-organization"><strong>Deferred task representation and organization</strong></a></li>
<li><a href="#delayed-task-scheduling"><strong>Delayed task scheduling</strong></a></li>
<li><a href="#user-event-task-scheduling"><strong>User event task scheduling</strong></a></li>
<li><a href="#event-loop-execution-framework"><strong>Event loop execution framework</strong></a></li>
<li><a href="#socket-io-event-description-and-its-organization"><strong>Socket I/O event description and its organization</strong></a></li>
<li><a href="#socket-io-event-processing-task-scheduling"><strong>Socket I/O event processing task scheduling</strong></a></li>
<li><a href="#live555-source-code-analysis-series"><strong>Live555 source code analysis series</strong></a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<p>Live555 consists of multiple modules, such as <strong>UsageEnvironment</strong>,
<strong>BasicUsageEnvironment</strong>, and <strong>groupsock</strong>. They provide event loops, input and output,
basic data structures, and network IO functions respectively, which can be seen as the
live555 infrastructure. In our analysis of the  live555 source code, we&apos;ll start with
these infrastructures. The basic data structure.</p>
<h2 id="hashtable"><a name="hashtable" class="anchor-navigation-ex-anchor" href="#hashtable"><i class="fa fa-link" aria-hidden="true"></i></a>1.1. HashTable</h2>
<p>First of all HashTable, this is a generic association container defined by
live555.</p>
<h2 id="usageenvironment--hashtable"><a name="usageenvironment--hashtable" class="anchor-navigation-ex-anchor" href="#usageenvironment--hashtable"><i class="fa fa-link" aria-hidden="true"></i></a>1.2. UsageEnvironment : HashTable</h2>
<p>In <strong>UsageEnvironment</strong>, The <code>HashTable</code> class defines an interface, the interface is
defined as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">class HashTable {
public:
  virtual ~HashTable();

  // The following must be implemented by a particular
  // implementation (subclass):
  static HashTable* create(int keyType);

  virtual void* Add(char const* key, void* value) = 0;
  // Returns the old value if different, otherwise 0
  virtual Boolean Remove(char const* key) = 0;
  virtual void* Lookup(char const* key) const = 0;
  // Returns 0 if not found
  virtual unsigned numEntries() const = 0;
  Boolean IsEmpty() const { return numEntries() == 0; }

  // Used to iterate through the members of the table:
  class Iterator {
  public:
    // The following must be implemented by a particular
    // implementation (subclass):
    static Iterator* create(HashTable const&amp; hashTable);

    virtual ~Iterator();

    virtual void* next(char const*&amp; key) = 0; // returns 0 if none

  protected:
    Iterator(); // abstract base class
  };

  // A shortcut that can be used to successively remove each of
  // the entries in the table (e.g., so that their values can be
  // deleted, if they happen to be pointers to allocated memory).
  void* RemoveNext();

  // Returns the first entry in the table.
  // (This is useful for deleting each entry in the table, if the entry&apos;s destructor also removes itself from the table.)
  void* getFirst();

protected:
  HashTable(); // abstract base class
};
// Warning: The following are deliberately the same as in
// Tcl&apos;s hash table implementation
int const STRING_HASH_KEYS = 0;
int const ONE_WORD_HASH_KEYS = 1;<br></div></div>

<p>Although <code>HashTable</code> to be defined as a paradigm associative containers, but it did
not use C ++ templates. In <code>HashTable</code>, the request key is a C-style string, that
is <code>char const*</code>, the value is <code>void*</code>, which can represent various types of
values. Just like the many container types in the C++ standard library, <code>HashTable</code> has
iterator class which is defined internally to traverse the container.</p>
<p>Other operations such as adding, removing, and finding elements are not much
different from other common container designs.</p>
<p><code>HashTable</code> Public class implements two template functions not related to specific
memory structure <code>RemoveNext()</code> and <code>getFirst()</code>, for the removal of these two
functions are the next element in the container and returns the value of the
element, and to obtain a first container elements, their The implementation is
as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">#include &quot;HashTable.hh&quot;
HashTable::HashTable() {
}
HashTable::~HashTable() {
}
HashTable::Iterator::Iterator() {
}
HashTable::Iterator::~Iterator() {}
void* HashTable::RemoveNext() {
  Iterator* iter = Iterator::create(*this);
  char const* key;
  void* removedValue = iter-&gt;next(key);
  if (removedValue != 0) Remove(key);
  delete iter;
  return removedValue;
}
void* HashTable::getFirst() {
  Iterator* iter = Iterator::create(*this);
  char const* key;
  void* firstValue = iter-&gt;next(key);
  delete iter;
  return firstValue;
}<br></div></div>

<p>Both of these functions are implemented by means of an iterator of the
container. <code>Iterator</code> Class <code>next(char const*&amp; key)</code> receives an outgoing parameter
for the key to return to the caller.</p>
<p>Defined by live555 from the perspective of interface
definition <code>HashTable</code>. Its <code>Iterator</code> class object is <code>Iterator</code> a static method of the
class <code>create(HashTable const&amp; hashTable)</code> is created, but the responsibility to
destroy the object is created in the caller here, which greatly undermined
the <code>HashTable</code> flexibility to achieve the interface, such as the creation of the
object and therefore can not do caching.</p>
<p><code>HashTable</code> Class and its iterator class <code>Iterator</code> each defining a static
method <code>create()</code>. Here the use of bridging the way <code>HashTable</code> of this method as a
bridge, like the <code>HashTable</code> interface and the implementation of the interface link
up. This class of static functions is defined in the class that implements the
interface.</p>
<p><code>HashTable</code> There are two types were identified using two integer
values, <code>STRING_HASH_KEYS</code> and <code>ONE_WORD_HASH_KEYS</code>. Of course, it relies
on <code>create()</code> a method according to <code>HashTable</code> still create objects of different
classes of objects created in the same class type may be <code>create()</code> design method
is understood to bridging, or factory methods.</p>
<h2 id="basicusageenvironment-&#x7684;-basichashtable"><a name="basicusageenvironment-&#x7684;-basichashtable" class="anchor-navigation-ex-anchor" href="#basicusageenvironment-&#x7684;-basichashtable"><i class="fa fa-link" aria-hidden="true"></i></a>1.3. BasicUsageEnvironment &#x7684; BasicHashTable</h2>
<p>The <strong>BasicUsageEnvironment</strong> <code>BasicHashTable</code> provides
a <code>HashTable</code> realization. <code>BasicHashTable</code> The definition is as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">// A simple hash table implementation, inspired by the hash table
// implementation used in Tcl 7.6: &lt;http://www.tcl.tk/&gt;
#define SMALL_HASH_TABLE_SIZE 4
class BasicHashTable: public HashTable {
private:
    class TableEntry; // forward
public:
  BasicHashTable(int keyType);
  virtual ~BasicHashTable();
  // Used to iterate through the members of the table:
  class Iterator; friend class Iterator; // to make Sun&apos;s C++ compiler happy
  class Iterator: public HashTable::Iterator {
  public:
    Iterator(BasicHashTable const&amp; table);
  private: // implementation of inherited pure virtual functions
    void* next(char const*&amp; key); // returns 0 if none
  private:
    BasicHashTable const&amp; fTable;
    unsigned fNextIndex; // index of next bucket to be enumerated after this
    TableEntry* fNextEntry; // next entry in the current bucket
  };
private: // implementation of inherited pure virtual functions
  virtual void* Add(char const* key, void* value);
  // Returns the old value if different, otherwise 0
  virtual Boolean Remove(char const* key);
  virtual void* Lookup(char const* key) const;
  // Returns 0 if not found
  virtual unsigned numEntries() const;
private:
  class TableEntry {
  public:
    TableEntry* fNext;
    char const* key;
    void* value;
  };
  TableEntry* lookupKey(char const* key, unsigned&amp; index) const;
    // returns entry matching &quot;key&quot;, or NULL if none
  Boolean keyMatches(char const* key1, char const* key2) const;
    // used to implement &quot;lookupKey()&quot;
  TableEntry* insertNewEntry(unsigned index, char const* key);
    // creates a new entry, and inserts it in the table
  void assignKey(TableEntry* entry, char const* key);
    // used to implement &quot;insertNewEntry()&quot;
  void deleteEntry(unsigned index, TableEntry* entry);
  void deleteKey(TableEntry* entry);
    // used to implement &quot;deleteEntry()&quot;
  void rebuild(); // rebuilds the table as its size increases
  unsigned hashIndexFromKey(char const* key) const;
    // used to implement many of the routines above
  unsigned randomIndex(uintptr_t i) const {
    return (unsigned)(((i*1103515245) &gt;&gt; fDownShift) &amp; fMask);
  }
private:
  TableEntry** fBuckets; // pointer to bucket array
  TableEntry* fStaticBuckets[SMALL_HASH_TABLE_SIZE];// used for small tables
  unsigned fNumBuckets, fNumEntries, fRebuildSize, fDownShift, fMask;
  int fKeyType;
};<br></div></div>

<p><code>BasicHashTable</code> A class is defined <code>TableEntry</code> to represent key-value
pairs. <code>fNext</code> The field is used to point to the next of the different key-value
pairs for the hash value conflict of the computed key.</p>
<p>View <code>BasicHashTable</code> of creation:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">BasicHashTable::BasicHashTable(int keyType)
  : fBuckets(fStaticBuckets), fNumBuckets(SMALL_HASH_TABLE_SIZE),
    fNumEntries(0), fRebuildSize(SMALL_HASH_TABLE_SIZE*REBUILD_MULTIPLIER),
    fDownShift(28), fMask(0x3), fKeyType(keyType) {
  for (unsigned i = 0; i &lt; SMALL_HASH_TABLE_SIZE; ++i) {
    fStaticBuckets[i] = NULL;
  }
}
. . . . . .
HashTable* HashTable::create(int keyType) {
  return new BasicHashTable(keyType);
}<br></div></div>


<p><code>BasicHashTable</code> With <code>TableEntry</code> preservation of all the key array pointer - value
pairs. When the class object is created, a small <code>TableEntry</code> array of
pointers <code>fStaticBuckets</code> will be created with the creation of objects
in <code>BasicHashTable</code>, save the key elements in this array directly to the
relatively little time in order to optimize performance when the element is
relatively small, reducing memory The overhead of allocation.</p>
<p><code>fBuckets</code> Save key point - the value of the <code>TableEntry</code> array of pointers, created
early in the object, which points to <code>fStaticBuckets</code> the time, while the expansion
in the hash bucket, it points to a newly allocated <code>TableEntry</code> array of
pointers. Access to the elements in the container is 
<code>fBuckets</code> done through. <code>fNumBuckets</code> For storing <code>TableEntry</code> the length of an array of
pointers. <code>fNumEntries</code> Used to hold the number of key-value pairs in the
container.<code>fRebuildSize</code> Hash bucket for the expansion threshold, that is,
when <code>BasicHashTable</code> stored in key-value pairs exceeds this value, the hash bucket
capacity is needed. <code>fDownShift</code> And <code>fMask</code> for calculating the hash value, the hash
value and the hash bucket maps to the capacity range.</p>
<h2 id="insert-an-element-into-the-basichashtable"><a name="insert-an-element-into-the-basichashtable" class="anchor-navigation-ex-anchor" href="#insert-an-element-into-the-basichashtable"><i class="fa fa-link" aria-hidden="true"></i></a>1.4. Insert an element into the BasicHashTable</h2>
<p>By <code>Add(char const* key, void* value)</code> the <code>BasicHashTable</code> insertion element, the
function is as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">void* BasicHashTable::Add(char const* key, void* value) {
  void* oldValue;
  unsigned index;
  TableEntry* entry = lookupKey(key, index);
  if (entry != NULL) {
    // There&apos;s already an item with this key
    oldValue = entry-&gt;value;
  } else {
    // There&apos;s no existing entry; create a new one:
    entry = insertNewEntry(index, key);
    oldValue = NULL;
  }
  entry-&gt;value = value;
  // If the table has become too large, rebuild it with more buckets:
  if (fNumEntries &gt;= fRebuildSize) rebuild();
  return oldValue;
}<br></div></div>


<p>The car that is inserted into the <code>BasicHashTable</code> is roughly as follows:</p>
<ol>
<li><p>Find the element in the <code>BasicHashTable</code> that matches the key of the key-value
pair you want to insert <code>TableEntry</code>.</p>
</li>
<li><p>If found, the old value of the element is stored in oldValuethe.</p>
</li>
<li><p>If none is found, by <code>insertNewEntry(index, key)</code> creating a TableEntryand
added to the hash bucket oldValueis assigned the value NULL.</p>
</li>
<li><p>To insert the key - value pair saved into a newly created or
found <code>TableEntry</code> in.</p>
</li>
<li><p>If the number of elements <code>BasicHashTable</code> exceeds the <code>fRebuildSize</code> size of the
hash bucket expansion.</p>
</li>
<li><p>Returns the old value of the element.</p>
</li>
</ol>
<p><code>BasicHashTable</code> with lookup key to be inserted - the element matching key value
pairs <code>TableEntry</code> are as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">BasicHashTable::TableEntry* BasicHashTable
::lookupKey(char const* key, unsigned&amp; index) const {
  TableEntry* entry;
  index = hashIndexFromKey(key);
  for (entry = fBuckets[index]; entry != NULL; entry = entry-&gt;fNext) {
    if (keyMatches(key, entry-&gt;key)) break;
  }
  return entry;
}
Boolean BasicHashTable
::keyMatches(char const* key1, char const* key2) const {
  // The way we check the keys for a match depends upon their type:
  if (fKeyType == STRING_HASH_KEYS) {
    return (strcmp(key1, key2) == 0);
  } else if (fKeyType == ONE_WORD_HASH_KEYS) {
    return (key1 == key2);
  } else {
    unsigned* k1 = (unsigned*)key1;
    unsigned* k2 = (unsigned*)key2;
    for (int i = 0; i &lt; fKeyType; ++i) {
      if (k1[i] != k2[i]) return False; // keys differ
    }
    return True;
  }
}
. . . . . .
unsigned BasicHashTable::hashIndexFromKey(char const* key) const {
  unsigned result = 0;
  if (fKeyType == STRING_HASH_KEYS) {
    while (1) {
      char c = *key++;
      if (c == 0) break;
      result += (result&lt;&lt;3) + (unsigned)c;
    }
    result &amp;= fMask;
  } else if (fKeyType == ONE_WORD_HASH_KEYS) {
    result = randomIndex((uintptr_t)key);
  } else {
    unsigned* k = (unsigned*)key;
    uintptr_t sum = 0;
    for (int i = 0; i &lt; fKeyType; ++i) {
      sum += k[i];
    }
    result = randomIndex(sum);
  }
  return result;
}<br></div></div>

<p><code>lookupKey()</code> First, by <code>hashIndexFromKey(key)</code> calculating the key based on a key on
the hash value, and this value is mapped to the hash bucket capacity range, to
give an index. Then based on the resulting index, find the element that matches
the passed key.</p>
<p>Here we can more clearly see the different types of <code>HashTable</code> differences between
the different treatment lies in key ways. For <code>STRING_HASH_KEYS</code> type <code>HashTable</code>,
the key is the content of the string pointed to by the incoming string pointer,
while the <code>ONE_WORD_HASH_KEYS</code> type <code>HashTable</code> is the incoming string pointer itself.</p>
<p>Calculate the final hash value and map the value to the hash bucket size range.
The process of getting the index is as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">unsigned randomIndex(uintptr_t i) const {
  return (unsigned)(((i*1103515245) &gt;&gt; fDownShift) &amp; fMask);
}<br></div></div>


<p><code>insertNewEntry(index, key)</code> Creating a <code>TableEntry</code> and added to the hash bucket is
as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">BasicHashTable::TableEntry* BasicHashTable
::insertNewEntry(unsigned index, char const* key) {
  TableEntry* entry = new TableEntry();
  entry-&gt;fNext = fBuckets[index];
  fBuckets[index] = entry;
  ++fNumEntries;
  assignKey(entry, key);
  return entry;
}
void BasicHashTable::assignKey(TableEntry* entry, char const* key) {
  // The way we assign the key depends upon its type:
  if (fKeyType == STRING_HASH_KEYS) {
    entry-&gt;key = strDup(key);
  } else if (fKeyType == ONE_WORD_HASH_KEYS) {
    entry-&gt;key = key;
  } else if (fKeyType &gt; 0) {
    unsigned* keyFrom = (unsigned*)key;
    unsigned* keyTo = new unsigned[fKeyType];
    for (int i = 0; i &lt; fKeyType; ++i) keyTo[i] = keyFrom[i];
    entry-&gt;key = (char const*)keyTo;
  }
}<br></div></div>


<p>It can be seen that the process of insertion is mainly</p>
<ol>
<li><p>Create a <code>TableEntry</code> object and insert it into the head of the <code>TableEntry</code>
element chain in the array of <code>TableEntry</code> pointers corresponding to the key.</p>
</li>
<li><p>Increase the count of the number of elements in the container.</p>
</li>
<li><p>Assign the passed key to the <code>TableEntry</code>.</p>
</li>
</ol>
<p>According to the <code>HashTable</code> different types of distribution keys in different
ways.</p>
<ol>
<li><p>For the <code>STRING_HASH_KEYS</code> type HashTable, you need to copy the contents of
the string pointed to by the incoming string pointer and assign it to
TableEntry key.</p>
</li>
<li><p>For the <code>ONE_WORD_HASH_KEYS</code> type <code>HashTable</code>, you need to assign the passed
string pointer itself to the <code>TableEntry</code> key.</p>
</li>
<li><p>For <code>fKeyType</code> the case of greater than 0, it is necessary before the contents
of the string pointer to the incoming string (the sizeof
(unsigned) <em><code>fKeyType</code>) copy byte, assigned to the TableEntry <code>key</code>. This kind
of code is really scary, in case the incoming key string length is less than
(sizeof(unsigned)</em> fKeyType) bytes? . . .</p>
</li>
</ol>
<p>Contrast <code>keyMatches()</code> and <code>assignKey()</code> implementation of a function, not difficult
to find, when the <code>HashTable</code> type <code>fKeyType</code> is greater than 0, and
not <code>ONE_WORD_HASH_KEYS</code> when the required length of the string as a key-value pair
in the hash table key is fixed to (sizeof (unsigned) * fKeyType) bytes.</p>
<p>Then, look at the process of expanding the hash bucket in the <code>BasicHashTable</code>:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">void BasicHashTable::rebuild() {
  // Remember the existing table size:
  unsigned oldSize = fNumBuckets;
  TableEntry** oldBuckets = fBuckets;
  // Create the new sized table:
  fNumBuckets *= 4;
  fBuckets = new TableEntry*[fNumBuckets];
  for (unsigned i = 0; i &lt; fNumBuckets; ++i) {
    fBuckets[i] = NULL;
  }
  fRebuildSize *= 4;
  fDownShift -= 2;
  fMask = (fMask&lt;&lt;2)|0x3;
  // Rehash the existing entries into the new table:
  for (TableEntry** oldChainPtr = oldBuckets; oldSize &gt; 0;
       --oldSize, ++oldChainPtr) {
    for (TableEntry* hPtr = *oldChainPtr; hPtr != NULL;
     hPtr = *oldChainPtr) {
      *oldChainPtr = hPtr-&gt;fNext;
      unsigned index = hashIndexFromKey(hPtr-&gt;key);
      hPtr-&gt;fNext = fBuckets[index];
      fBuckets[index] = hPtr;
    }
  }
  // Free the old bucket array, if it was dynamically allocated:
  if (oldBuckets != fStaticBuckets) delete[] oldBuckets;
}<br></div></div>


<p>Here is,</p>
<ol>
<li><p>To <code>fBuckets</code> allocate a new memory, the capacity of the original 4-fold.</p>
</li>
<li><p>Appropriately updated <code>fNumBuckets</code>, <code>fRebuildSize</code>, <code>fDownShift</code> and <code>fMask</code> so on.</p>
</li>
<li><p>The older of <code>fBuckets</code> the elements, according to the elements keyand a new
hash bucket capacity, moved to a new <code>fBuckets</code> medium.</p>
</li>
<li><p>Old release according to the needs <code>fBuckets</code> of memory.</p>
</li>
</ol>
<h2 id="find-elements-in-the-basichashtable"><a name="find-elements-in-the-basichashtable" class="anchor-navigation-ex-anchor" href="#find-elements-in-the-basichashtable"><i class="fa fa-link" aria-hidden="true"></i></a>1.5. Find elements in the BasicHashTable</h2>
<p>Then look at the process of finding elements in the <code>BasicHashTable</code>:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">void* BasicHashTable::Lookup(char const* key) const {
  unsigned index;
  TableEntry* entry = lookupKey(key, index);
  if (entry == NULL) return NULL; // no such entry
  return entry-&gt;value;
}<br></div></div>

<p>This process is mainly based on key, by <code>lookupKey()</code> finds the corresponding
elements <code>TableEntry</code>, and then returns its value.</p>
<h2 id="remove-elements-from-basichashtable"><a name="remove-elements-from-basichashtable" class="anchor-navigation-ex-anchor" href="#remove-elements-from-basichashtable"><i class="fa fa-link" aria-hidden="true"></i></a>1.6. Remove elements from BasicHashTable</h2>
<p>To see the process of removing elements from a <code>BasicHashTable</code>:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">Boolean BasicHashTable::Remove(char const* key) {
  unsigned index;
  TableEntry* entry = lookupKey(key, index);
  if (entry == NULL) return False; // no such entry
  deleteEntry(index, entry);
  return True;
}
. . . . . .
void BasicHashTable::deleteEntry(unsigned index, TableEntry* entry) {
  TableEntry** ep = &amp;fBuckets[index];
  Boolean foundIt = False;
  while (*ep != NULL) {
    if (*ep == entry) {
      foundIt = True;
      *ep = entry-&gt;fNext;
      break;
    }
    ep = &amp;((*ep)-&gt;fNext);
  }
  if (!foundIt) { // shouldn&apos;t happen
#ifdef DEBUG
    fprintf(stderr, &quot;BasicHashTable[%p]::deleteEntry(%d,%p): internal error - not found (first entry %p&quot;, this, index, entry, fBuckets[index]);
    if (fBuckets[index] != NULL) fprintf(stderr, &quot;, next entry %p&quot;, fBuckets[index]-&gt;fNext);
    fprintf(stderr, &quot;)\n&quot;);
#endif
  }
  --fNumEntries;
  deleteKey(entry);
  delete entry;
}
void BasicHashTable::deleteKey(TableEntry* entry) {
  // The way we delete the key depends upon its type:
  if (fKeyType == ONE_WORD_HASH_KEYS) {
    entry-&gt;key = NULL;
  } else {
    delete[] (char*)entry-&gt;key;
    entry-&gt;key = NULL;
  }
}<br></div></div>

<p>The process of removing the element <code>BasicHashTable</code>, but also inevitably find the
first element <code>BasicHashTable</code> after <code>TableEntry</code> in, found by <code>deleteEntry()</code> removing
elements.</p>
<p>In the <code>deleteEntry()</code> middle, from the first element <code>BasicHashTable</code> is removed out,
and then by <code>deleteKey()</code> releasing the memory occupied key, then release the
memory occupied <code>TableEntry</code> itself. Here <code>TableEntry</code> from
the <code>BasicHashTable</code> removal of the out of use following this approach:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">TableEntry** ep = &amp;fBuckets[index];
Boolean foundIt = False;
while (*ep != NULL) {
  if (*ep == entry) {
    foundIt = True;
    *ep = entry-&gt;fNext;
    break;
  }
  ep = &amp;((*ep)-&gt;fNext);
}<br></div></div>

<p>By traversing the linked list through the secondary pointer, the element is
removed. I remember this is a way of writing inspired by Linus God in this
scene. Deleting an element from a linked list, using several temporary
variables, or adding a lot of judgments, is weak.</p>
<h2 id="traversing-the-basichashtable-through-iterator"><a name="traversing-the-basichashtable-through-iterator" class="anchor-navigation-ex-anchor" href="#traversing-the-basichashtable-through-iterator"><i class="fa fa-link" aria-hidden="true"></i></a>1.7. Traversing the BasicHashTable through Iterator</h2>
<p>You can use <code>BasicHashTable</code> defined <code>Iterator</code> to traverse it. The process is as
follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">BasicHashTable::Iterator::Iterator(BasicHashTable const&amp; table)
  : fTable(table), fNextIndex(0), fNextEntry(NULL) {
}
void* BasicHashTable::Iterator::next(char const*&amp; key) {
  while (fNextEntry == NULL) {
    if (fNextIndex &gt;= fTable.fNumBuckets) return NULL;
    fNextEntry = fTable.fBuckets[fNextIndex++];
  }
  BasicHashTable::TableEntry* entry = fNextEntry;
  fNextEntry = entry-&gt;fNext;
  key = entry-&gt;key;
  return entry-&gt;value;
}
. . . . . .
HashTable::Iterator* HashTable::Iterator::create(HashTable const&amp; hashTable) {
  // &quot;hashTable&quot; is assumed to be a BasicHashTable
  return new BasicHashTable::Iterator((BasicHashTable const&amp;)hashTable);
}<br></div></div>

<p><code>BasicHashTable</code> Of <code>fBuckets</code> each element are stored a <code>TableEntry</code> linked list. Here
we will traverse one by one.</p>
<p>live555 definition <code>HashTable</code> content there is to it.</p>
<h2 id="usageenvironment"><a name="usageenvironment" class="anchor-navigation-ex-anchor" href="#usageenvironment"><i class="fa fa-link" aria-hidden="true"></i></a>1.8. UsageEnvironment</h2>
<p>In live555, the <code>UsageEnvironment</code> class plays the role of a simple controller. In
the <code>UsageEnvironment</code> module, the <code>UsageEnvironment</code> class is defined as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">class TaskScheduler; // forward
// An abstract base class, subclassed for each use of the library
class UsageEnvironment {
public:
  Boolean reclaim();
      // returns True iff we were actually able to delete our object
  // task scheduler:
  TaskScheduler&amp; taskScheduler() const {return fScheduler;}
  // result message handling:
  typedef char const* MsgString;
  virtual MsgString getResultMsg() const = 0;
  virtual void setResultMsg(MsgString msg) = 0;
  virtual void setResultMsg(MsgString msg1, MsgString msg2) = 0;
  virtual void setResultMsg(MsgString msg1, MsgString msg2, MsgString msg3) = 0;
  virtual void setResultErrMsg(MsgString msg, int err = 0) = 0;
    // like setResultMsg(), except that an &apos;errno&apos; message is appended.  (If &quot;err == 0&quot;, the &quot;getErrno()&quot; code is used instead.)
  virtual void appendToResultMsg(MsgString msg) = 0;
  virtual void reportBackgroundError() = 0;
    // used to report a (previously set) error message within
    // a background event
  virtual void internalError(); // used to &apos;handle&apos; a &apos;should not occur&apos;-type error condition within the library.
  // &apos;errno&apos;
  virtual int getErrno() const = 0;
  // &apos;console&apos; output:
  virtual UsageEnvironment&amp; operator&lt;&lt;(char const* str) = 0;
  virtual UsageEnvironment&amp; operator&lt;&lt;(int i) = 0;
  virtual UsageEnvironment&amp; operator&lt;&lt;(unsigned u) = 0;
  virtual UsageEnvironment&amp; operator&lt;&lt;(double d) = 0;
  virtual UsageEnvironment&amp; operator&lt;&lt;(void* p) = 0;
  // a pointer to additional, optional, client-specific state
  void* liveMediaPriv;
  void* groupsockPriv;
protected:
  UsageEnvironment(TaskScheduler&amp; scheduler); // abstract base class
  virtual ~UsageEnvironment(); // we are deleted only by reclaim()
private:
  TaskScheduler&amp; fScheduler;
};<br></div></div>

<p><code>UsageEnvironment</code> Class holds <code>TaskScheduler</code> a reference, and providing a text
output operation for outputting information, also provides other operation
acquisition errno, the processing routine when the internal error
occurs <code>internalError()</code>, and the destruction of their own
operation. <code>UsageEnvironment</code> The class itself implements the following functions:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">Boolean UsageEnvironment::reclaim() {
  // We delete ourselves only if we have no remainining state:
  if (liveMediaPriv == NULL &amp;&amp; groupsockPriv == NULL) {
    delete this;
    return True;
  }
  return False;
}
UsageEnvironment::UsageEnvironment(TaskScheduler&amp; scheduler)
  : liveMediaPriv(NULL), groupsockPriv(NULL), fScheduler(scheduler) {
}
UsageEnvironment::~UsageEnvironment() {
}
// By default, we handle &apos;should not occur&apos;-type library errors by calling abort().  Subclasses can redefine this, if desired.
// (If your runtime library doesn&apos;t define the &quot;abort()&quot; function, then define your own (e.g., that does nothing).)
void UsageEnvironment::internalError() {
  abort();
}<br></div></div>

<p>These functions are relatively simple and will not be described here.</p>
<p><code>UsageEnvironment</code> Is an interface class, <code>BasicUsageEnvironment</code> module by two
classes <code>BasicUsageEnvironment</code> and <code>BasicUsageEnvironment0</code> provides one of its
implementation. <code>BasicUsageEnvironment0</code> The class provides an implementation of
the set of functions that directly manipulate the string, which is defined as
follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">class BasicUsageEnvironment0: public UsageEnvironment {
public:
  // redefined virtual functions:
  virtual MsgString getResultMsg() const;
  virtual void setResultMsg(MsgString msg);
  virtual void setResultMsg(MsgString msg1,
            MsgString msg2);
  virtual void setResultMsg(MsgString msg1,
            MsgString msg2,
            MsgString msg3);
  virtual void setResultErrMsg(MsgString msg, int err = 0);
  virtual void appendToResultMsg(MsgString msg);
  virtual void reportBackgroundError();
protected:
  BasicUsageEnvironment0(TaskScheduler&amp; taskScheduler);
  virtual ~BasicUsageEnvironment0();
private:
  void reset();
  char fResultMsgBuffer[RESULT_MSG_BUFFER_MAX];
  unsigned fCurBufferSize;
  unsigned fBufferMaxSize;
};<br></div></div>

<p>This class defines a buffer with a size of <code>RESULT_MSG_BUFFER_MAX</code>. The
implementation of the class is as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">BasicUsageEnvironment0::BasicUsageEnvironment0(TaskScheduler&amp; taskScheduler)
  : UsageEnvironment(taskScheduler),
    fBufferMaxSize(RESULT_MSG_BUFFER_MAX) {
  reset();
}
BasicUsageEnvironment0::~BasicUsageEnvironment0() {
}
void BasicUsageEnvironment0::reset() {
  fCurBufferSize = 0;
  fResultMsgBuffer[fCurBufferSize] = &apos;\0&apos;;
}
// Implementation of virtual functions:
char const* BasicUsageEnvironment0::getResultMsg() const {
  return fResultMsgBuffer;
}
void BasicUsageEnvironment0::setResultMsg(MsgString msg) {
  reset();
  appendToResultMsg(msg);
}
void BasicUsageEnvironment0::setResultMsg(MsgString msg1, MsgString msg2) {
  setResultMsg(msg1);
  appendToResultMsg(msg2);
}
void BasicUsageEnvironment0::setResultMsg(MsgString msg1, MsgString msg2,
                       MsgString msg3) {
  setResultMsg(msg1, msg2);
  appendToResultMsg(msg3);
}
void BasicUsageEnvironment0::setResultErrMsg(MsgString msg, int err) {
  setResultMsg(msg);
  if (err == 0) err = getErrno();
. . . . . .
  appendToResultMsg(strerror(err));
#endif
}
void BasicUsageEnvironment0::appendToResultMsg(MsgString msg) {
  char* curPtr = &amp;fResultMsgBuffer[fCurBufferSize];
  unsigned spaceAvailable = fBufferMaxSize - fCurBufferSize;
  unsigned msgLength = strlen(msg);
  // Copy only enough of &quot;msg&quot; as will fit:
  if (msgLength &gt; spaceAvailable-1) {
    msgLength = spaceAvailable-1;
  }
  memmove(curPtr, (char*)msg, msgLength);
  fCurBufferSize += msgLength;
  fResultMsgBuffer[fCurBufferSize] = &apos;\0&apos;;
}
void BasicUsageEnvironment0::reportBackgroundError() {
  fputs(getResultMsg(), stderr);
}<br></div></div>

<p>This set of functions provides the ability to add incoming strings to the buffer
and output the contents of the buffer to standard output.</p>
<p><code>BasicUsageEnvironment</code> The class provides the set of operators for outputting
basic data types. The definition of this class is as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">class BasicUsageEnvironment: public BasicUsageEnvironment0 {
public:
  static BasicUsageEnvironment* createNew(TaskScheduler&amp; taskScheduler);
  // redefined virtual functions:
  virtual int getErrno() const;
  virtual UsageEnvironment&amp; operator&lt;&lt;(char const* str);
  virtual UsageEnvironment&amp; operator&lt;&lt;(int i);
  virtual UsageEnvironment&amp; operator&lt;&lt;(unsigned u);
  virtual UsageEnvironment&amp; operator&lt;&lt;(double d);
  virtual UsageEnvironment&amp; operator&lt;&lt;(void* p);
protected:
  BasicUsageEnvironment(TaskScheduler&amp; taskScheduler);
      // called only by &quot;createNew()&quot; (or subclass constructors)
  virtual ~BasicUsageEnvironment();
};<br></div></div>

<p>The definition is relatively simple. Then look at its implementation:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">BasicUsageEnvironment::BasicUsageEnvironment(TaskScheduler&amp; taskScheduler)
: BasicUsageEnvironment0(taskScheduler) {
. . . . . .
}
BasicUsageEnvironment::~BasicUsageEnvironment() {
}
BasicUsageEnvironment*
BasicUsageEnvironment::createNew(TaskScheduler&amp; taskScheduler) {
  return new BasicUsageEnvironment(taskScheduler);
}
int BasicUsageEnvironment::getErrno() const {
#if defined(__WIN32__) || defined(_WIN32) || defined(_WIN32_WCE)
  return WSAGetLastError();
#else
  return errno;
#endif
}
UsageEnvironment&amp; BasicUsageEnvironment::operator&lt;&lt;(char const* str) {
  if (str == NULL) str = &quot;(NULL)&quot;; // sanity check
  fprintf(stderr, &quot;%s&quot;, str);
  return *this;
}
UsageEnvironment&amp; BasicUsageEnvironment::operator&lt;&lt;(int i) {
  fprintf(stderr, &quot;%d&quot;, i);
  return *this;
}
UsageEnvironment&amp; BasicUsageEnvironment::operator&lt;&lt;(unsigned u) {
  fprintf(stderr, &quot;%u&quot;, u);
  return *this;
}
UsageEnvironment&amp; BasicUsageEnvironment::operator&lt;&lt;(double d) {
  fprintf(stderr, &quot;%f&quot;, d);
  return *this;
}
UsageEnvironment&amp; BasicUsageEnvironment::operator&lt;&lt;(void* p) {
  fprintf(stderr, &quot;%p&quot;, p);
  return *this;
}<br></div></div>

<p><code>BasicUsageEnvironment</code> Class also provides a function to create a static
object <code>createNew()</code> used to create <code>BasicUsageEnvironment</code> objects. For those
implementations of the output operator, it is relatively straightforward.</p>
<p>I feel that the live555 implementation of this set of I / O functions is not
very good, the C + + standard library has a good implementation of these
interfaces, but live555 does not seem to have the intention of introducing the C++ standard library.</p>
<h2 id="taskscheduler"><a name="taskscheduler" class="anchor-navigation-ex-anchor" href="#taskscheduler"><i class="fa fa-link" aria-hidden="true"></i></a>1.9. TaskScheduler</h2>
<p><code>TaskScheduler</code> is the task scheduler in live555, which implements the event loop
for live555. In the <code>UsageEnvironment</code> module, the <code>TaskScheduler</code> class is defined
as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">typedef void TaskFunc(void* clientData);
typedef void* TaskToken;
typedef u_int32_t EventTriggerId;
class TaskScheduler {
public:
  virtual ~TaskScheduler();
  virtual TaskToken scheduleDelayedTask(int64_t microseconds, TaskFunc* proc,
                    void* clientData) = 0;
    // Schedules a task to occur (after a delay) when we next
    // reach a scheduling point.
    // (Does not delay if &quot;microseconds&quot; &lt;= 0)
    // Returns a token that can be used in a subsequent call to
    // unscheduleDelayedTask() or rescheduleDelayedTask()
        // (but only if the task has not yet occurred).
  virtual void unscheduleDelayedTask(TaskToken&amp; prevTask) = 0;
    // (Has no effect if &quot;prevTask&quot; == NULL)
        // Sets &quot;prevTask&quot; to NULL afterwards.
        // Note: This MUST NOT be called if the scheduled task has already occurred.
  virtual void rescheduleDelayedTask(TaskToken&amp; task,
                     int64_t microseconds, TaskFunc* proc,
                     void* clientData);
        // Combines &quot;unscheduleDelayedTask()&quot; with &quot;scheduleDelayedTask()&quot;
        // (setting &quot;task&quot; to the new task token).
        // Note: This MUST NOT be called if the scheduled task has already occurred.
  // For handling socket operations in the background (from the event loop):
  typedef void BackgroundHandlerProc(void* clientData, int mask);
    // Possible bits to set in &quot;mask&quot;.  (These are deliberately defined
    // the same as those in Tcl, to make a Tcl-based subclass easy.)
    #define SOCKET_READABLE    (1&lt;&lt;1)
    #define SOCKET_WRITABLE    (1&lt;&lt;2)
    #define SOCKET_EXCEPTION   (1&lt;&lt;3)
  virtual void setBackgroundHandling(int socketNum, int conditionSet, BackgroundHandlerProc* handlerProc, void* clientData) = 0;
  void disableBackgroundHandling(int socketNum) { setBackgroundHandling(socketNum, 0, NULL, NULL); }
  virtual void moveSocketHandling(int oldSocketNum, int newSocketNum) = 0;
        // Changes any socket handling for &quot;oldSocketNum&quot; so that occurs with &quot;newSocketNum&quot; instead.
  virtual void doEventLoop(char volatile* watchVariable = NULL) = 0;
      // Causes further execution to take place within the event loop.
      // Delayed tasks, background I/O handling, and other events are handled, sequentially (as a single thread of control).
      // (If &quot;watchVariable&quot; is not NULL, then we return from this routine when *watchVariable != 0)
  virtual EventTriggerId createEventTrigger(TaskFunc* eventHandlerProc) = 0;
      // Creates a &apos;trigger&apos; for an event, which - if it occurs - will be handled (from the event loop) using &quot;eventHandlerProc&quot;.
      // (Returns 0 iff no such trigger can be created (e.g., because of implementation limits on the number of triggers).)
  virtual void deleteEventTrigger(EventTriggerId eventTriggerId) = 0;
  virtual void triggerEvent(EventTriggerId eventTriggerId, void* clientData = NULL) = 0;
      // Causes the (previously-registered) handler function for the specified event to be handled (from the event loop).
      // The handler function is called with &quot;clientData&quot; as parameter.
      // Note: This function (unlike other library functions) may be called from an external thread
      // - to signal an external event.  (However, &quot;triggerEvent()&quot; should not be called with the
      // same &apos;event trigger id&apos; from different threads.)
  // The following two functions are deprecated, and are provided for backwards-compatibility only:
  void turnOnBackgroundReadHandling(int socketNum, BackgroundHandlerProc* handlerProc, void* clientData) {
    setBackgroundHandling(socketNum, SOCKET_READABLE, handlerProc, clientData);
  }
  void turnOffBackgroundReadHandling(int socketNum) { disableBackgroundHandling(socketNum); }
  virtual void internalError(); // used to &apos;handle&apos; a &apos;should not occur&apos;-type error condition within the library.
protected:
  TaskScheduler(); // abstract base class
};<br></div></div>

<p><code>TaskScheduler</code> The interfaces can be divided into the following groups:</p>
<ol>
<li><p>Schedule timer tasks. This includes <code>scheduleDelayedTask()</code>, <code>unscheduleDelayedTask()</code> and <code>rescheduleDelayedTask()</code> these
functions, which are used to schedule a task delay, cancel a delayed task,
and reschedule a delay task.</p>
</li>
<li><p>Schedule Socket I/O processing operations in the background. This
includes <code>setBackgroundHandling()</code>, <code>disableBackgroundHandling()</code>, <code>moveSocketHandling()</code>, <code>turnOnBackgroundReadHandling()</code> and <code>turnOffBackgroundReadHandling()</code> so that several functions are used to set, modify or cancel processing program
on a particular socket I / O event.</p>
</li>
<li><p>User event scheduling. This includes <code>createEventTrigger()</code>, <code>deleteEventTrigger()</code> and <code>triggerEvent()</code> so a
few functions that are used to create, delete, and trigger a user-defined events.</p>
</li>
<li><p>Execute the event loop. This a <code>doEventLoop()</code> complete function, which is
usually the main loop of the program application.</p>
</li>
<li><p>Internal error handler. This refers to the <code>internalError()</code> function
for <code>TaskScheduler</code> an internal fault occurs, performs some processing.</p>
</li>
</ol>
<p><code>TaskScheduler</code> The class itself provides an implementation of several simple
functions:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">TaskScheduler::TaskScheduler() {
}
TaskScheduler::~TaskScheduler() {
}
void TaskScheduler::rescheduleDelayedTask(TaskToken&amp; task,
                      int64_t microseconds, TaskFunc* proc,
                      void* clientData) {
  unscheduleDelayedTask(task);
  task = scheduleDelayedTask(microseconds, proc, clientData);
}
// By default, we handle &apos;should not occur&apos;-type library errors by calling abort().  Subclasses can redefine this, if desired.
void TaskScheduler::internalError() {
  abort();
}<br></div></div>

<p>They are simple and easy to understand, so I won&apos;t go into details here.</p>
<p><code>TaskScheduler</code> The implementation of the interface is also provided in the
<code>BasicUsageEnvironment</code> module . And <code>UsageEnvironment</code> the case is similar to the
interface, <code>TaskScheduler</code> an interface, implemented by the same two classes,
respectively <code>BasicTaskScheduler</code>, and <code>BasicTaskScheduler0</code> wherein 
<code>BasicTaskScheduler0</code> classes implement Group 1, Group 3 interface, and we
mentioned earlier <code>doEventLoop()</code> frame, and <code>BasicTaskScheduler</code> is used to implement
the second group interface and implement <code>doEventLoop()</code> the event loop the loop.</p>
<p><code>BasicTaskScheduler0</code> The class is defined as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">class HandlerSet; // forward
#define MAX_NUM_EVENT_TRIGGERS 32
// An abstract base class, useful for subclassing
// (e.g., to redefine the implementation of socket event handling)
class BasicTaskScheduler0: public TaskScheduler {
public:
  virtual ~BasicTaskScheduler0();
  virtual void SingleStep(unsigned maxDelayTime = 0) = 0;
      // &quot;maxDelayTime&quot; is in microseconds.  It allows a subclass to impose a limit
      // on how long &quot;select()&quot; can delay, in case it wants to also do polling.
      // 0 (the default value) means: There&apos;s no maximum; just look at the delay queue
public:
  // Redefined virtual functions:
  virtual TaskToken scheduleDelayedTask(int64_t microseconds, TaskFunc* proc,
                void* clientData);
  virtual void unscheduleDelayedTask(TaskToken&amp; prevTask);
  virtual void doEventLoop(char volatile* watchVariable);
  virtual EventTriggerId createEventTrigger(TaskFunc* eventHandlerProc);
  virtual void deleteEventTrigger(EventTriggerId eventTriggerId);
  virtual void triggerEvent(EventTriggerId eventTriggerId, void* clientData = NULL);
protected:
  BasicTaskScheduler0();
protected:
  // To implement delayed operations:
  DelayQueue fDelayQueue;
  // To implement background reads:
  HandlerSet* fHandlers;
  int fLastHandledSocketNum;
  // To implement event triggers:
  EventTriggerId volatile fTriggersAwaitingHandling; // implemented as a 32-bit bitmap
  EventTriggerId fLastUsedTriggerMask; // implemented as a 32-bit bitmap
  TaskFunc* fTriggeredEventHandlers[MAX_NUM_EVENT_TRIGGERS];
  void* fTriggeredEventClientDatas[MAX_NUM_EVENT_TRIGGERS];
  unsigned fLastUsedTriggerNum; // in the range [0,MAX_NUM_EVENT_TRIGGERS)
};<br></div></div>

<p><code>BasicTaskScheduler0</code> Class member function, basically inherited
from <code>TaskScheduler</code> class, it is to realize that part of the interface functions,
but it adds a new virtual function <code>SingleStep()</code>, for let subclasses override, to
achieve a single event loop iteration.</p>
<p><code>BasicTaskScheduler0</code> Class member variables is clearly divided into three
groups: <code>fDelayQueue</code> to implement a timer operation;
<code>fHandlers</code> and <code>fLastHandledSocketNum</code> for implementing the Socket I / O
event processing operation;
<code>fTriggersAwaitingHandling</code>, <code>fLastUsedTriggerMask</code>, <code>fTriggeredEventHandlers</code>, <code>fTriggeredEventClientDatas</code>,
and <code>fLastUsedTriggerNum</code> for implementing a user event.</p>
<p><em>For <code>fHandlers</code> and <code>fLastHandledSocketNum</code>, in fact, feel no need to </em>
<em><code>BasicTaskScheduler0</code> define the class. Throughout the <code>BasicTaskScheduler0</code> class of
the entire implementation, in addition to the initialization these two member
variables, there is no other access operations. From the functions of the two
variables, it is not in <code>BasicTaskScheduler0</code> the range of duty class. These two
variables actually feel in <code>BasicTaskScheduler</code> class a little more appropriate.</em></p>
<p><code>BasicTaskScheduler0</code> The class object creation and destruction process is as
follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">BasicTaskScheduler0::BasicTaskScheduler0()
  : fLastHandledSocketNum(-1), fTriggersAwaitingHandling(0), fLastUsedTriggerMask(1), fLastUsedTriggerNum(MAX_NUM_EVENT_TRIGGERS-1) {
  fHandlers = new HandlerSet;
  for (unsigned i = 0; i &lt; MAX_NUM_EVENT_TRIGGERS; ++i) {
    fTriggeredEventHandlers[i] = NULL;
    fTriggeredEventClientDatas[i] = NULL;
  }
}
BasicTaskScheduler0::~BasicTaskScheduler0() {
  delete fHandlers;
}<br></div></div>

<p>During the creation of a class object, member objects are created and/or
initialized, and when the object is destroyed, the member objects are destroyed.</p>
<h2 id="representation-of-time"><a name="representation-of-time" class="anchor-navigation-ex-anchor" href="#representation-of-time"><i class="fa fa-link" aria-hidden="true"></i></a>1.10. Representation of time</h2>
<p>In the <code>BasicUsageEnvironment</code> live555 module, with <code>Timeval</code> the class to describe
time, and use <code>DelayInterval</code> described delay time. The definitions of these two
classes are as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">class Timeval {
public:
  time_base_seconds seconds() const {
    return fTv.tv_sec;
  }
  time_base_seconds seconds() {
    return fTv.tv_sec;
  }
  time_base_seconds useconds() const {
    return fTv.tv_usec;
  }
  time_base_seconds useconds() {
    return fTv.tv_usec;
  }
  int operator&gt;=(Timeval const&amp; arg2) const;
  int operator&lt;=(Timeval const&amp; arg2) const {
    return arg2 &gt;= *this;
  }
  int operator&lt;(Timeval const&amp; arg2) const {
    return !(*this &gt;= arg2);
  }
  int operator&gt;(Timeval const&amp; arg2) const {
    return arg2 &lt; *this;
  }
  int operator==(Timeval const&amp; arg2) const {
    return *this &gt;= arg2 &amp;&amp; arg2 &gt;= *this;
  }
  int operator!=(Timeval const&amp; arg2) const {
    return !(*this == arg2);
  }
  void operator+=(class DelayInterval const&amp; arg2);
  void operator-=(class DelayInterval const&amp; arg2);
  // returns ZERO iff arg2 &gt;= arg1
protected:
  Timeval(time_base_seconds seconds, time_base_seconds useconds) {
    fTv.tv_sec = seconds; fTv.tv_usec = useconds;
  }
private:
  time_base_seconds&amp; secs() {
    return (time_base_seconds&amp;)fTv.tv_sec;
  }
  time_base_seconds&amp; usecs() {
    return (time_base_seconds&amp;)fTv.tv_usec;
  }
  struct timeval fTv;
};
. . . . . .
class DelayInterval: public Timeval {
public:
  DelayInterval(time_base_seconds seconds, time_base_seconds useconds)
    : Timeval(seconds, useconds) {}
};<br></div></div>

<p><code>DelayInterval</code> Class is basically <code>Timeval</code> like an alias, but the reason why such a
redefinition of class, probably mainly for readability maintain
it. <code>Timeval</code> Standard class library storage time of <code>struct timeval</code> storage time
value of the structure, but by the operator overloading, a number of operator
functions convenient operation time value. The implementation of the operator
function defined as a member function is as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">int Timeval::operator&gt;=(const Timeval&amp; arg2) const {
  return seconds() &gt; arg2.seconds()
    || (seconds() == arg2.seconds()
    &amp;&amp; useconds() &gt;= arg2.useconds());
}
void Timeval::operator+=(const DelayInterval&amp; arg2) {
  secs() += arg2.seconds(); usecs() += arg2.useconds();
  if (useconds() &gt;= MILLION) {
    usecs() -= MILLION;
    ++secs();
  }
}
void Timeval::operator-=(const DelayInterval&amp; arg2) {
  secs() -= arg2.seconds(); usecs() -= arg2.useconds();
  if ((int)useconds() &lt; 0) {
    usecs() += MILLION;
    --secs();
  }
  if ((int)seconds() &lt; 0)
    secs() = usecs() = 0;
}<br></div></div>

<p>The implementation of these operator functions is relatively straightforward.</p>
<p>In addition to these operators defined by member operator functions, the
operators of these non-member functions are also included:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">#ifndef max
inline Timeval max(Timeval const&amp; arg1, Timeval const&amp; arg2) {
  return arg1 &gt;= arg2 ? arg1 : arg2;
}
#endif
#ifndef min
inline Timeval min(Timeval const&amp; arg1, Timeval const&amp; arg2) {
  return arg1 &lt;= arg2 ? arg1 : arg2;
}
#endif
. . . . . .
DelayInterval operator-(const Timeval&amp; arg1, const Timeval&amp; arg2) {
  time_base_seconds secs = arg1.seconds() - arg2.seconds();
  time_base_seconds usecs = arg1.useconds() - arg2.useconds();
  if ((int)usecs &lt; 0) {
    usecs += MILLION;
    --secs;
  }
  if ((int)secs &lt; 0)
    return DELAY_ZERO;
  else
    return DelayInterval(secs, usecs);
}
///// DelayInterval /////
DelayInterval operator*(short arg1, const DelayInterval&amp; arg2) {
  time_base_seconds result_seconds = arg1*arg2.seconds();
  time_base_seconds result_useconds = arg1*arg2.useconds();
  time_base_seconds carry = result_useconds/MILLION;
  result_useconds -= carry*MILLION;
  result_seconds += carry;
  return DelayInterval(result_seconds, result_useconds);
}
#ifndef INT_MAX
#define INT_MAX    0x7FFFFFFF
#endif
const DelayInterval DELAY_ZERO(0, 0);
const DelayInterval DELAY_SECOND(1, 0);
const DelayInterval DELAY_MINUTE = 60*DELAY_SECOND;
const DelayInterval DELAY_HOUR = 60*DELAY_MINUTE;
const DelayInterval DELAY_DAY = 24*DELAY_HOUR;
const DelayInterval ETERNITY(INT_MAX, MILLION-1);
// used internally to make the implementation work<br></div></div>

<p>Their implementation is also relatively straightforward.</p>
<h2 id="deferred-task-representation-and-organization"><a name="deferred-task-representation-and-organization" class="anchor-navigation-ex-anchor" href="#deferred-task-representation-and-organization"><i class="fa fa-link" aria-hidden="true"></i></a>1.11. Deferred task representation and organization</h2>
<p>In the <code>BasicUsageEnvironment</code> live555 module, with <code>DelayQueueEntry</code> class
represents a delay task. The class is defined as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">class DelayQueueEntry {
public:
  virtual ~DelayQueueEntry();
  intptr_t token() {
    return fToken;
  }
protected: // abstract base class
  DelayQueueEntry(DelayInterval delay);
  virtual void handleTimeout();
private:
  friend class DelayQueue;
  DelayQueueEntry* fNext;
  DelayQueueEntry* fPrev;
  DelayInterval fDeltaTimeRemaining;
  intptr_t fToken;
  static intptr_t tokenCounter;
};<br></div></div>

<p>Delay tasks identified by token, token when the object is created, by means of
global <code>tokenCounter</code> production. <code>fDeltaTimeRemaining</code> Used to indicate the interval
between the time that the delayed task needs to be executed and the current
time. Made <code>fNext</code> and <code>fPrev</code> not difficult to guess, it is doubly linked list in
<code>BasicUsageEnvironment</code> module to organize delayed tasks. <code>handleTimeout()</code> A
function is the body of a deferred task and needs to be implemented by a
concrete subclass.</p>
<p><code>DelayQueueEntry</code> The specific implementation of the class is as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">intptr_t DelayQueueEntry::tokenCounter = 0;
DelayQueueEntry::DelayQueueEntry(DelayInterval delay)
  : fDeltaTimeRemaining(delay) {
  fNext = fPrev = this;
  fToken = ++tokenCounter;
}
DelayQueueEntry::~DelayQueueEntry() {
}
void DelayQueueEntry::handleTimeout() {
  delete this;
}<br></div></div>

<p><code>BasicUsageEnvironment</code> modules actually used <code>AlarmHandler</code> to describe the delayed
tasks, which are defined as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">class AlarmHandler: public DelayQueueEntry {
public:
  AlarmHandler(TaskFunc* proc, void* clientData, DelayInterval timeToDelay)
    : DelayQueueEntry(timeToDelay), fProc(proc), fClientData(clientData) {
  }
private: // redefined virtual functions
  virtual void handleTimeout() {
    (*fProc)(fClientData);
    DelayQueueEntry::handleTimeout();
  }
private:
  TaskFunc* fProc;
  void* fClientData;
};<br></div></div>

<p><code>BasicUsageEnvironment</code> need modules <code>DelayQueueEntry</code> represent classes and delay
the task organization, whereas in the interface layer, i.e. <code>TaskScheduler</code> in the
through <code>TaskFunc</code> represented delay data pointer and user tasks.
<code>AlarmHandler</code> Assist in the conversion of the structure of the interface to
the implementation of the structure.</p>
<p><code>BasicUsageEnvironment</code> module uses <code>DelayQueue</code> the <code>DelayQueueEntry</code> organized as a
doubly linked list, the class is defined as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">class DelayQueue: public DelayQueueEntry {
public:
  DelayQueue();
  virtual ~DelayQueue();
  void addEntry(DelayQueueEntry* newEntry); // returns a token for the entry
  void updateEntry(DelayQueueEntry* entry, DelayInterval newDelay);
  void updateEntry(intptr_t tokenToFind, DelayInterval newDelay);
  void removeEntry(DelayQueueEntry* entry); // but doesn&apos;t delete it
  DelayQueueEntry* removeEntry(intptr_t tokenToFind); // but doesn&apos;t delete it
  DelayInterval const&amp; timeToNextAlarm();
  void handleAlarm();
private:
  DelayQueueEntry* head() { return fNext; }
  DelayQueueEntry* findEntryByToken(intptr_t token);
  void synchronize(); // bring the &apos;time remaining&apos; fields up-to-date
  _EventTime fLastSyncTime;
};<br></div></div>s


First look at the `DelayQueue` class object construction and destruction process:

<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">DelayQueue::DelayQueue()
  : DelayQueueEntry(ETERNITY) {
  fLastSyncTime = TimeNow();
}
DelayQueue::~DelayQueue() {
  while (fNext != this) {
    DelayQueueEntry* entryToRemove = fNext;
    removeEntry(entryToRemove);
    delete entryToRemove;
  }
}<br></div></div>

<p>Then take a look at the process of adding elements to the list:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">void DelayQueue::addEntry(DelayQueueEntry* newEntry) {
  synchronize();
  DelayQueueEntry* cur = head();
  while (newEntry-&gt;fDeltaTimeRemaining &gt;= cur-&gt;fDeltaTimeRemaining) {
    newEntry-&gt;fDeltaTimeRemaining -= cur-&gt;fDeltaTimeRemaining;
    cur = cur-&gt;fNext;
  }
  cur-&gt;fDeltaTimeRemaining -= newEntry-&gt;fDeltaTimeRemaining;
  // Add &quot;newEntry&quot; to the queue, just before &quot;cur&quot;:
  newEntry-&gt;fNext = cur;
  newEntry-&gt;fPrev = cur-&gt;fPrev;
  cur-&gt;fPrev = newEntry-&gt;fPrev-&gt;fNext = newEntry;
}
. . . . . .
void DelayQueue::synchronize() {
  // First, figure out how much time has elapsed since the last sync:
  _EventTime timeNow = TimeNow();
  if (timeNow &lt; fLastSyncTime) {
    // The system clock has apparently gone back in time; reset our sync time and return:
    fLastSyncTime  = timeNow;
    return;
  }
  DelayInterval timeSinceLastSync = timeNow - fLastSyncTime;
  fLastSyncTime = timeNow;
  // Then, adjust the delay queue for any entries whose time is up:
  DelayQueueEntry* curEntry = head();
  while (timeSinceLastSync &gt;= curEntry-&gt;fDeltaTimeRemaining) {
    timeSinceLastSync -= curEntry-&gt;fDeltaTimeRemaining;
    curEntry-&gt;fDeltaTimeRemaining = DELAY_ZERO;
    curEntry = curEntry-&gt;fNext;
  }
  curEntry-&gt;fDeltaTimeRemaining -= timeSinceLastSync;
}<br></div></div>

<p>With these two functions, can be more clearly seen in <code>DelayQueue</code> the organization
is how delayed tasks. <code>DelayQueue</code> Because it is one in itself <code>DelayQueueEntry</code>, it
is actually a circular doubly linked list. It <code>fNext</code> points to the head of the
logical linked list element, but it is itself trailing elements of this
list. Each element of the doubly linked list <code>fDeltaTimeRemaining</code> stored is a time
point that the task should be scheduled for execution, the task that precedes it
should be a difference between the scheduled time point of execution when the
value is 0, it indicates that The task needs to be executed. This means that
it <code>DelayQueue</code> is a bidirectional circular ordered list, arranged in order of the
required execution time.</p>
<p><code>removeEntry()</code> Used to remove a task from a doubly linked list:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">void DelayQueue::removeEntry(DelayQueueEntry* entry) {
  if (entry == NULL || entry-&gt;fNext == NULL) return;
  entry-&gt;fNext-&gt;fDeltaTimeRemaining += entry-&gt;fDeltaTimeRemaining;
  entry-&gt;fPrev-&gt;fNext = entry-&gt;fNext;
  entry-&gt;fNext-&gt;fPrev = entry-&gt;fPrev;
  entry-&gt;fNext = entry-&gt;fPrev = NULL;
  // in case we should try to remove it again
}
DelayQueueEntry* DelayQueue::removeEntry(intptr_t tokenToFind) {
  DelayQueueEntry* entry = findEntryByToken(tokenToFind);
  removeEntry(entry);
  return entry;
}
. . . . . .
DelayQueueEntry* DelayQueue::findEntryByToken(intptr_t tokenToFind) {
  DelayQueueEntry* cur = head();
  while (cur != this) {
    if (cur-&gt;token() == tokenToFind) return cur;
    cur = cur-&gt;fNext;
  }
  return NULL;
}<br></div></div>

<p><code>removeEntry(DelayQueueEntry* entry)</code> In, in <code>entry-&gt;fNext == NULL</code> a direct return
to the establishment, but also because <code>DelayQueue</code> actually a two-way circular
linked list sake.</p>
<p><code>DelayQueue</code> An interface for updating the execution time of delayed tasks is also
provided:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">void DelayQueue::updateEntry(DelayQueueEntry* entry, DelayInterval newDelay) {
  if (entry == NULL) return;
  removeEntry(entry);
  entry-&gt;fDeltaTimeRemaining = newDelay;
  addEntry(entry);
}
void DelayQueue::updateEntry(intptr_t tokenToFind, DelayInterval newDelay) {
  DelayQueueEntry* entry = findEntryByToken(tokenToFind);
  updateEntry(entry, newDelay);
}<br></div></div>

<p>Further, <code>timeToNextAlarm()</code> for calculating the time of the most recent execution
of a task, and <code>handleAlarm()</code> is used to perform this task.</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">DelayInterval const&amp; DelayQueue::timeToNextAlarm() {
  if (head()-&gt;fDeltaTimeRemaining == DELAY_ZERO) return DELAY_ZERO; // a common case
  synchronize();
  return head()-&gt;fDeltaTimeRemaining;
}
void DelayQueue::handleAlarm() {
  if (head()-&gt;fDeltaTimeRemaining != DELAY_ZERO) synchronize();
  if (head()-&gt;fDeltaTimeRemaining == DELAY_ZERO) {
    // This event is due to be handled:
    DelayQueueEntry* toRemove = head();
    removeEntry(toRemove); // do this first, in case handler accesses queue
    toRemove-&gt;handleTimeout();
  }
}<br></div></div>

<h2 id="delayed-task-scheduling"><a name="delayed-task-scheduling" class="anchor-navigation-ex-anchor" href="#delayed-task-scheduling"><i class="fa fa-link" aria-hidden="true"></i></a>1.12. Delayed task scheduling</h2>
<p>After seeing the representation of time in the live555&apos;s <code>BasicUsageEnvironment</code>
module, and the representation and organization of the delayed task, look at the
scheduling of the delayed task.</p>
<p><code>BasicTaskScheduler0</code> Classes <code>scheduleDelayedTask()</code> and <code>unscheduleDelayedTask()</code> implemented
timer task scheduling function, respectively, and for scheduling a task to
cancel a delay of the delay task, they are implemented as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">TaskToken BasicTaskScheduler0::scheduleDelayedTask(int64_t microseconds,
                         TaskFunc* proc,
                         void* clientData) {
  if (microseconds &lt; 0) microseconds = 0;
  DelayInterval timeToDelay((long)(microseconds/1000000), (long)(microseconds%1000000));
  AlarmHandler* alarmHandler = new AlarmHandler(proc, clientData, timeToDelay);
  fDelayQueue.addEntry(alarmHandler);
  return (void*)(alarmHandler-&gt;token());
}
void BasicTaskScheduler0::unscheduleDelayedTask(TaskToken&amp; prevTask) {
  DelayQueueEntry* alarmHandler = fDelayQueue.removeEntry((intptr_t)prevTask);
  prevTask = NULL;
  delete alarmHandler;
}<br></div></div>

<p>Task scheduling delay is the delay into the task <code>DelayQueue</code>, the task is delayed
and canceled, the task from <code>DelayQueue</code> the removal of.</p>
<p>Let&apos;s look at the process of delaying the execution of the task.</p>
<h2 id="user-event-task-scheduling"><a name="user-event-task-scheduling" class="anchor-navigation-ex-anchor" href="#user-event-task-scheduling"><i class="fa fa-link" aria-hidden="true"></i></a>1.13. User event task scheduling</h2>
<p>The user event task dispatch interface allows the caller to create a task and
trigger the task to execute in the event loop. This set of interfaces mainly
includes such a few: <code>createEventTrigger()</code>, <code>deleteEventTrigger()</code> and <code>triggerEvent()</code>,
they are used to create tasks, delete tasks, and trigger task execution.</p>
<p>The implementation of these interfaces is as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">EventTriggerId BasicTaskScheduler0::createEventTrigger(TaskFunc* eventHandlerProc) {
  unsigned i = fLastUsedTriggerNum;
  EventTriggerId mask = fLastUsedTriggerMask;
  do {
    i = (i+1)%MAX_NUM_EVENT_TRIGGERS;
    mask &gt;&gt;= 1;
    if (mask == 0) mask = 0x80000000;
    if (fTriggeredEventHandlers[i] == NULL) {
      // This trigger number is free; use it:
      fTriggeredEventHandlers[i] = eventHandlerProc;
      fTriggeredEventClientDatas[i] = NULL; // sanity
      fLastUsedTriggerMask = mask;
      fLastUsedTriggerNum = i;
      return mask;
    }
  } while (i != fLastUsedTriggerNum);
  // All available event triggers are allocated; return 0 instead:
  return 0;
}
void BasicTaskScheduler0::deleteEventTrigger(EventTriggerId eventTriggerId) {
  fTriggersAwaitingHandling &amp;=~ eventTriggerId;
  if (eventTriggerId == fLastUsedTriggerMask) { // common-case optimization:
    fTriggeredEventHandlers[fLastUsedTriggerNum] = NULL;
    fTriggeredEventClientDatas[fLastUsedTriggerNum] = NULL;
  } else {
    // &quot;eventTriggerId&quot; should have just one bit set.
    // However, we do the reasonable thing if the user happened to &apos;or&apos; together two or more &quot;EventTriggerId&quot;s:
    EventTriggerId mask = 0x80000000;
    for (unsigned i = 0; i &lt; MAX_NUM_EVENT_TRIGGERS; ++i) {
      if ((eventTriggerId&amp;mask) != 0) {
    fTriggeredEventHandlers[i] = NULL;
    fTriggeredEventClientDatas[i] = NULL;
      }
      mask &gt;&gt;= 1;
    }
  }
}
void BasicTaskScheduler0::triggerEvent(EventTriggerId eventTriggerId, void* clientData) {
  // First, record the &quot;clientData&quot;.  (Note that we allow &quot;eventTriggerId&quot; to be a combination of bits for multiple events.)
  EventTriggerId mask = 0x80000000;
  for (unsigned i = 0; i &lt; MAX_NUM_EVENT_TRIGGERS; ++i) {
    if ((eventTriggerId&amp;mask) != 0) {
      fTriggeredEventClientDatas[i] = clientData;
    }
    mask &gt;&gt;= 1;
  }
  // Then, note this event as being ready to be handled.
  // (Note that because this function (unlike others in the library) can be called from an external thread, we do this last, to
  //  reduce the risk of a race condition.)
  fTriggersAwaitingHandling |= eventTriggerId;
}<br></div></div>

<p><code>BasicTaskScheduler0</code> Of <code>fTriggeredEventHandlers</code> and <code>fTriggeredEventClientDatas</code> user
data for saving mission itself, which are the main task of preservation
function, as well as passing when performing tasks. They are all arrays, each
task occupies one element, and the elements at the same index belong to the same
task. The length of the array <code>MAX_NUM_EVENT_TRIGGERS</code> is 32, which means that the
maximum number of tasks that can be created is 32.</p>
<p><code>fTriggersAwaitingHandling</code> Used to record which tasks are currently triggered. The
trigger state of each task corresponds to one of the bits. When the
corresponding position is 1, it indicates that the task is triggered and needs
to be executed; otherwise, it does not need to be executed. For
example, <code>fTriggeredEventHandlers</code> and <code>fTriggeredEventClientDatas</code> trigger status of
the task 0 in the index corresponds to <code>fTriggersAwaitingHandling</code> the highest
level, triggering state of the task at index 1, corresponding to the next high
level, and so on.</p>
<p>Create a task, that is,
in <code>fTriggeredEventHandlers</code> and <code>fTriggeredEventClientDatas</code> for the task to find a
free position, the preserved body of the function pointer of the task, the task
of the index returned in <code>fTriggersAwaitingHandling</code> the mask corresponding bit
in, as a task of identification. <code>fLastUsedTriggerNum</code> To prevent
traverse <code>fTriggeredEventHandlers</code> an infinite loop when looking.</p>
<p>Delete a task that is to remove all data-related tasks, including
resetting <code>fTriggersAwaitingHandlingtrigger</code> state, as well
as <code>fTriggeredEventHandlers</code> and <code>fTriggeredEventClientDatas</code> the main function
pointer and user data in the task.</p>
<p>Task trigger event is set for the task in <code>fTriggersAwaitingHandling</code> the
corresponding position, and set the task data. The actual execution of the task
also needs to be performed in the event loop.</p>
<h2 id="event-loop-execution-framework"><a name="event-loop-execution-framework" class="anchor-navigation-ex-anchor" href="#event-loop-execution-framework"><i class="fa fa-link" aria-hidden="true"></i></a>1.14. Event loop execution framework</h2>
<p><code>BasicTaskScheduler0</code> Performed by the event loop <code>doEventLoop()</code> complete function,
specifically implemented as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">void BasicTaskScheduler0::doEventLoop(char volatile* watchVariable) {
  // Repeatedly loop, handling readble sockets and timed events:
  while (1) {
    if (watchVariable != NULL &amp;&amp; *watchVariable != 0) break;
    SingleStep();
  }
}<br></div></div>

<p>The main special concern is the incoming parameters <code>watchVariable</code>: the caller
can use this parameter to control outside the event loop and when the event loop
ends.</p>
<h2 id="socket-io-event-description-and-its-organization"><a name="socket-io-event-description-and-its-organization" class="anchor-navigation-ex-anchor" href="#socket-io-event-description-and-its-organization"><i class="fa fa-link" aria-hidden="true"></i></a>1.15. Socket I/O event description and its organization</h2>
<p><code>BasicUsageEnvironment</code> module, with a <code>HandlerDescriptor</code> description of the
processing procedures of the event and the event occurred to listening socket,
the class is defined as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">class HandlerDescriptor {
  HandlerDescriptor(HandlerDescriptor* nextHandler);
  virtual ~HandlerDescriptor();
public:
  int socketNum;
  int conditionSet;
  TaskScheduler::BackgroundHandlerProc* handlerProc;
  void* clientData;
private:
  // Descriptors are linked together in a doubly-linked list:
  friend class HandlerSet;
  friend class HandlerIterator;
  HandlerDescriptor* fNextHandler;
  HandlerDescriptor* fPrevHandler;
};<br></div></div>

<p><code>socketNum</code> For the socket to be listened to, <code>conditionSet</code> describe the event on the
socket to be listened to <code>handlerProc</code>, the handler when the event occurs,
and <code>clientData</code> the user data passed to the event
handler. While <code>fNextHandler</code> and  then used to 
<code>HandlerDescriptor</code> organize. Not difficult to guess, <code>BasicUsageEnvironment</code>
module <code>HandlerDescriptor</code> is to be organized as a doubly linked list.</p>
<p><code>HandlerDescriptor</code> The implementation of the class is as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">HandlerDescriptor::HandlerDescriptor(HandlerDescriptor* nextHandler)
  : conditionSet(0), handlerProc(NULL) {
  // Link this descriptor into a doubly-linked list:
  if (nextHandler == this) { // initialization
    fNextHandler = fPrevHandler = this;
  } else {
    fNextHandler = nextHandler;
    fPrevHandler = nextHandler-&gt;fPrevHandler;
    nextHandler-&gt;fPrevHandler = this;
    fPrevHandler-&gt;fNextHandler = this;
  }
}
HandlerDescriptor::~HandlerDescriptor() {
  // Unlink this descriptor from a doubly-linked list:
  fNextHandler-&gt;fPrevHandler = fPrevHandler;
  fPrevHandler-&gt;fNextHandler = fNextHandler;
}<br></div></div>

<p><code>BasicUsageEnvironment</code> module, used <code>HandlerSet</code> to maintain all <code>HandlerDescriptor</code>,
class definition as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">class HandlerSet {
public:
  HandlerSet();
  virtual ~HandlerSet();
  void assignHandler(int socketNum, int conditionSet, TaskScheduler::BackgroundHandlerProc* handlerProc, void* clientData);
  void clearHandler(int socketNum);
  void moveHandler(int oldSocketNum, int newSocketNum);
private:
  HandlerDescriptor* lookupHandler(int socketNum);
private:
  friend class HandlerIterator;
  HandlerDescriptor fHandlers;
};<br></div></div>

<p><code>HandlerSet</code>/<code>HandlerDescriptor</code> Design <code>with DelayQueue</code>/<code>DelayQueueEntry</code> design is
very similar.<code>HandlerSet</code> The implementation is as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">HandlerSet::HandlerSet()
  : fHandlers(&amp;fHandlers) {
  fHandlers.socketNum = -1; // shouldn&apos;t ever get looked at, but in case...
}
HandlerSet::~HandlerSet() {
  // Delete each handler descriptor:
  while (fHandlers.fNextHandler != &amp;fHandlers) {
    delete fHandlers.fNextHandler; // changes fHandlers-&gt;fNextHandler
  }
}
void HandlerSet
::assignHandler(int socketNum, int conditionSet, TaskScheduler::BackgroundHandlerProc* handlerProc, void* clientData) {
  // First, see if there&apos;s already a handler for this socket:
  HandlerDescriptor* handler = lookupHandler(socketNum);
  if (handler == NULL) { // No existing handler, so create a new descr:
    handler = new HandlerDescriptor(fHandlers.fNextHandler);
    handler-&gt;socketNum = socketNum;
  }
  handler-&gt;conditionSet = conditionSet;
  handler-&gt;handlerProc = handlerProc;
  handler-&gt;clientData = clientData;
}
void HandlerSet::clearHandler(int socketNum) {
  HandlerDescriptor* handler = lookupHandler(socketNum);
  delete handler;
}
void HandlerSet::moveHandler(int oldSocketNum, int newSocketNum) {
  HandlerDescriptor* handler = lookupHandler(oldSocketNum);
  if (handler != NULL) {
    handler-&gt;socketNum = newSocketNum;
  }
}
HandlerDescriptor* HandlerSet::lookupHandler(int socketNum) {
  HandlerDescriptor* handler;
  HandlerIterator iter(*this);
  while ((handler = iter.next()) != NULL) {
    if (handler-&gt;socketNum == socketNum) break;
  }
  return handler;
}<br></div></div>

<p><code>HandlerSet</code> Similarly, it is designed as a <code>HandlerDescriptor</code> two-way circulation
list, but there is no significance to the order in which the elements.</p>
<p>The <code>BasicUsageEnvironment</code> module also provides an iterator<code>HandlerIterator</code> for
traversal <code>HandlerSet</code>, which is defined and implemented as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">class HandlerIterator {
public:
  HandlerIterator(HandlerSet&amp; handlerSet);
  virtual ~HandlerIterator();
  HandlerDescriptor* next(); // returns NULL if none
  void reset();
private:
  HandlerSet&amp; fOurSet;
  HandlerDescriptor* fNextPtr;
};
///////////////////////////////////// Implementation
HandlerIterator::HandlerIterator(HandlerSet&amp; handlerSet)
  : fOurSet(handlerSet) {
  reset();
}
HandlerIterator::~HandlerIterator() {
}
void HandlerIterator::reset() {
  fNextPtr = fOurSet.fHandlers.fNextHandler;
}
HandlerDescriptor* HandlerIterator::next() {
  HandlerDescriptor* result = fNextPtr;
  if (result == &amp;fOurSet.fHandlers) { // no more
    result = NULL;
  } else {
    fNextPtr = fNextPtr-&gt;fNextHandler;
  }
  return result;
}<br></div></div>

<p>In summary, you can listen to events on each socket, and executes the handler
when an event occurs, the event listener on the socket and the event handler
from the <code>HandlerDescriptor</code> description; all <code>HandlerDescriptor</code> by
the <code>HandlerSet</code> organization as a two-way circular list, actually between elements
The order has no meaning, and the newly added elements are placed in the logical
head of the linked list.</p>
<h2 id="socket-io-event-processing-task-scheduling"><a name="socket-io-event-processing-task-scheduling" class="anchor-navigation-ex-anchor" href="#socket-io-event-processing-task-scheduling"><i class="fa fa-link" aria-hidden="true"></i></a>1.16. Socket I/O event processing task scheduling</h2>
<p>Socket I / O event processing task scheduling are <code>BasicTaskScheduler</code> completed
class, this class definition is as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">class BasicTaskScheduler: public BasicTaskScheduler0 {
public:
  static BasicTaskScheduler* createNew(unsigned maxSchedulerGranularity = 10000/*microseconds*/);
  virtual ~BasicTaskScheduler();
protected:
  BasicTaskScheduler(unsigned maxSchedulerGranularity);
      // called only by &quot;createNew()&quot;
  static void schedulerTickTask(void* clientData);
  void schedulerTickTask();
protected:
  // Redefined virtual functions:
  virtual void SingleStep(unsigned maxDelayTime);
  virtual void setBackgroundHandling(int socketNum, int conditionSet, BackgroundHandlerProc* handlerProc, void* clientData);
  virtual void moveSocketHandling(int oldSocketNum, int newSocketNum);
protected:
  // To implement background reads:
  HandlerSet* fHandlers;
  int fLastHandledSocketNum;
  unsigned fMaxSchedulerGranularity;
  // To implement background operations:
  int fMaxNumSockets;
  fd_set fReadSet;
  fd_set fWriteSet;
  fd_set fExceptionSet;
. . . . . .
};<br></div></div>

<p><code>fHandlers</code> For the organization <code>HandlerDescriptor</code>, <code>fReadSet</code>, <code>fWriteSet</code>, <code>fExceptionSet</code> and
 <code>fMaxNumSockets</code> mainly in order to adapt <code>select()</code> the interface, it is used to describe the event to
listen for its readable, writable event, socket set of unusual events, as well
as to listen socket in socket number of the largest.</p>
<p>Socket I / O event processing task scheduling
by <code>setBackgroundHandling()</code> <code>and moveSocketHandling()</code> two complete functions, they
are implemented as follows:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">void BasicTaskScheduler
  ::setBackgroundHandling(int socketNum, int conditionSet, BackgroundHandlerProc* handlerProc, void* clientData) {
  if (socketNum &lt; 0) return;
#if !defined(__WIN32__) &amp;&amp; !defined(_WIN32) &amp;&amp; defined(FD_SETSIZE)
  if (socketNum &gt;= (int)(FD_SETSIZE)) return;
#endif
  FD_CLR((unsigned)socketNum, &amp;fReadSet);
  FD_CLR((unsigned)socketNum, &amp;fWriteSet);
  FD_CLR((unsigned)socketNum, &amp;fExceptionSet);
  if (conditionSet == 0) {
    fHandlers-&gt;clearHandler(socketNum);
    if (socketNum+1 == fMaxNumSockets) {
      --fMaxNumSockets;
    }
  } else {
    fHandlers-&gt;assignHandler(socketNum, conditionSet, handlerProc, clientData);
    if (socketNum+1 &gt; fMaxNumSockets) {
      fMaxNumSockets = socketNum+1;
    }
    if (conditionSet&amp;SOCKET_READABLE) FD_SET((unsigned)socketNum, &amp;fReadSet);
    if (conditionSet&amp;SOCKET_WRITABLE) FD_SET((unsigned)socketNum, &amp;fWriteSet);
    if (conditionSet&amp;SOCKET_EXCEPTION) FD_SET((unsigned)socketNum, &amp;fExceptionSet);
  }
}
void BasicTaskScheduler::moveSocketHandling(int oldSocketNum, int newSocketNum) {
  if (oldSocketNum &lt; 0 || newSocketNum &lt; 0) return; // sanity check
#if !defined(__WIN32__) &amp;&amp; !defined(_WIN32) &amp;&amp; defined(FD_SETSIZE)
  if (oldSocketNum &gt;= (int)(FD_SETSIZE) || newSocketNum &gt;= (int)(FD_SETSIZE)) return; // sanity check
#endif
  if (FD_ISSET(oldSocketNum, &amp;fReadSet)) {FD_CLR((unsigned)oldSocketNum, &amp;fReadSet); FD_SET((unsigned)newSocketNum, &amp;fReadSet);}
  if (FD_ISSET(oldSocketNum, &amp;fWriteSet)) {FD_CLR((unsigned)oldSocketNum, &amp;fWriteSet); FD_SET((unsigned)newSocketNum, &amp;fWriteSet);}
  if (FD_ISSET(oldSocketNum, &amp;fExceptionSet)) {FD_CLR((unsigned)oldSocketNum, &amp;fExceptionSet); FD_SET((unsigned)newSocketNum, &amp;fExceptionSet);}
  fHandlers-&gt;moveHandler(oldSocketNum, newSocketNum);
  if (oldSocketNum+1 == fMaxNumSockets) {
    --fMaxNumSockets;
  }
  if (newSocketNum+1 &gt; fMaxNumSockets) {
    fMaxNumSockets = newSocketNum+1;
  }
}<br></div></div>

<p>For <code>setBackgroundHandling()</code>, when <code>conditionSet</code> is a non-zero value, updated or
new listen for a specific socket; is 0, the listening socket will
clear. <code>moveSocketHandling()</code> Update the listener for socket events.</p>
<p><code>BasicTaskScheduler</code> The <code>SingleStep()</code> realization of a single event loop iteration:</p>
<div class="ace"><div class="aceCode" data-config="{&quot;edit&quot;:false,&quot;lang&quot;:&quot;c_cpp&quot;,&quot;check&quot;:false,&quot;theme&quot;:&quot;monokai&quot;}">void BasicTaskScheduler::SingleStep(unsigned maxDelayTime) {
  fd_set readSet = fReadSet; // make a copy for this select() call
  fd_set writeSet = fWriteSet; // ditto
  fd_set exceptionSet = fExceptionSet; // ditto
  DelayInterval const&amp; timeToDelay = fDelayQueue.timeToNextAlarm();
  struct timeval tv_timeToDelay;
  tv_timeToDelay.tv_sec = timeToDelay.seconds();
  tv_timeToDelay.tv_usec = timeToDelay.useconds();
  // Very large &quot;tv_sec&quot; values cause select() to fail.
  // Don&apos;t make it any larger than 1 million seconds (11.5 days)
  const long MAX_TV_SEC = MILLION;
  if (tv_timeToDelay.tv_sec &gt; MAX_TV_SEC) {
    tv_timeToDelay.tv_sec = MAX_TV_SEC;
  }
  // Also check our &quot;maxDelayTime&quot; parameter (if it&apos;s &gt; 0):
  if (maxDelayTime &gt; 0 &amp;&amp;
      (tv_timeToDelay.tv_sec &gt; (long)maxDelayTime/MILLION ||
       (tv_timeToDelay.tv_sec == (long)maxDelayTime/MILLION &amp;&amp;
    tv_timeToDelay.tv_usec &gt; (long)maxDelayTime%MILLION))) {
    tv_timeToDelay.tv_sec = maxDelayTime/MILLION;
    tv_timeToDelay.tv_usec = maxDelayTime%MILLION;
  }
  int selectResult = select(fMaxNumSockets, &amp;readSet, &amp;writeSet, &amp;exceptionSet, &amp;tv_timeToDelay);
  if (selectResult &lt; 0) {
#if defined(__WIN32__) || defined(_WIN32)
    int err = WSAGetLastError();
    // For some unknown reason, select() in Windoze sometimes fails with WSAEINVAL if
    // it was called with no entries set in &quot;readSet&quot;.  If this happens, ignore it:
    if (err == WSAEINVAL &amp;&amp; readSet.fd_count == 0) {
      err = EINTR;
      // To stop this from happening again, create a dummy socket:
      if (fDummySocketNum &gt;= 0) closeSocket(fDummySocketNum);
      fDummySocketNum = socket(AF_INET, SOCK_DGRAM, 0);
      FD_SET((unsigned)fDummySocketNum, &amp;fReadSet);
    }
    if (err != EINTR) {
#else
    if (errno != EINTR &amp;&amp; errno != EAGAIN) {
#endif
    // Unexpected error - treat this as fatal:
#if !defined(_WIN32_WCE)
    perror(&quot;BasicTaskScheduler::SingleStep(): select() fails&quot;);
    // Because this failure is often &quot;Bad file descriptor&quot; - which is caused by an invalid socket number (i.e., a socket number
    // that had already been closed) being used in &quot;select()&quot; - we print out the sockets that were being used in &quot;select()&quot;,
    // to assist in debugging:
    fprintf(stderr, &quot;socket numbers used in the select() call:&quot;);
    for (int i = 0; i &lt; 10000; ++i) {
      if (FD_ISSET(i, &amp;fReadSet) || FD_ISSET(i, &amp;fWriteSet) || FD_ISSET(i, &amp;fExceptionSet)) {
        fprintf(stderr, &quot; %d(&quot;, i);
        if (FD_ISSET(i, &amp;fReadSet)) fprintf(stderr, &quot;r&quot;);
        if (FD_ISSET(i, &amp;fWriteSet)) fprintf(stderr, &quot;w&quot;);
        if (FD_ISSET(i, &amp;fExceptionSet)) fprintf(stderr, &quot;e&quot;);
        fprintf(stderr, &quot;)&quot;);
      }
    }
    fprintf(stderr, &quot;\n&quot;);
#endif
    internalError();
      }
  }
  // Call the handler function for one readable socket:
  HandlerIterator iter(*fHandlers);
  HandlerDescriptor* handler;
  // To ensure forward progress through the handlers, begin past the last
  // socket number that we handled:
  if (fLastHandledSocketNum &gt;= 0) {
    while ((handler = iter.next()) != NULL) {
      if (handler-&gt;socketNum == fLastHandledSocketNum) break;
    }
    if (handler == NULL) {
      fLastHandledSocketNum = -1;
      iter.reset(); // start from the beginning instead
    }
  }
  while ((handler = iter.next()) != NULL) {
    int sock = handler-&gt;socketNum; // alias
    int resultConditionSet = 0;
    if (FD_ISSET(sock, &amp;readSet) &amp;&amp; FD_ISSET(sock, &amp;fReadSet)/*sanity check*/) resultConditionSet |= SOCKET_READABLE;
    if (FD_ISSET(sock, &amp;writeSet) &amp;&amp; FD_ISSET(sock, &amp;fWriteSet)/*sanity check*/) resultConditionSet |= SOCKET_WRITABLE;
    if (FD_ISSET(sock, &amp;exceptionSet) &amp;&amp; FD_ISSET(sock, &amp;fExceptionSet)/*sanity check*/) resultConditionSet |= SOCKET_EXCEPTION;
    if ((resultConditionSet&amp;handler-&gt;conditionSet) != 0 &amp;&amp; handler-&gt;handlerProc != NULL) {
      fLastHandledSocketNum = sock;
          // Note: we set &quot;fLastHandledSocketNum&quot; before calling the handler,
          // in case the handler calls &quot;doEventLoop()&quot; reentrantly.
      (*handler-&gt;handlerProc)(handler-&gt;clientData, resultConditionSet);
      break;
    }
  }
  if (handler == NULL &amp;&amp; fLastHandledSocketNum &gt;= 0) {
    // We didn&apos;t call a handler, but we didn&apos;t get to check all of them,
    // so try again from the beginning:
    iter.reset();
    while ((handler = iter.next()) != NULL) {
      int sock = handler-&gt;socketNum; // alias
      int resultConditionSet = 0;
      if (FD_ISSET(sock, &amp;readSet) &amp;&amp; FD_ISSET(sock, &amp;fReadSet)/*sanity check*/) resultConditionSet |= SOCKET_READABLE;
      if (FD_ISSET(sock, &amp;writeSet) &amp;&amp; FD_ISSET(sock, &amp;fWriteSet)/*sanity check*/) resultConditionSet |= SOCKET_WRITABLE;
      if (FD_ISSET(sock, &amp;exceptionSet) &amp;&amp; FD_ISSET(sock, &amp;fExceptionSet)/*sanity check*/) resultConditionSet |= SOCKET_EXCEPTION;
      if ((resultConditionSet&amp;handler-&gt;conditionSet) != 0 &amp;&amp; handler-&gt;handlerProc != NULL) {
    fLastHandledSocketNum = sock;
        // Note: we set &quot;fLastHandledSocketNum&quot; before calling the handler,
            // in case the handler calls &quot;doEventLoop()&quot; reentrantly.
    (*handler-&gt;handlerProc)(handler-&gt;clientData, resultConditionSet);
    break;
      }
    }
    if (handler == NULL) fLastHandledSocketNum = -1;//because we didn&apos;t call a handler
  }
  // Also handle any newly-triggered event (Note that we do this *after* calling a socket handler,
  // in case the triggered event handler modifies The set of readable sockets.)
  if (fTriggersAwaitingHandling != 0) {
    if (fTriggersAwaitingHandling == fLastUsedTriggerMask) {
      // Common-case optimization for a single event trigger:
      fTriggersAwaitingHandling &amp;=~ fLastUsedTriggerMask;
      if (fTriggeredEventHandlers[fLastUsedTriggerNum] != NULL) {
    (*fTriggeredEventHandlers[fLastUsedTriggerNum])(fTriggeredEventClientDatas[fLastUsedTriggerNum]);
      }
    } else {
      // Look for an event trigger that needs handling (making sure that we make forward progress through all possible triggers):
      unsigned i = fLastUsedTriggerNum;
      EventTriggerId mask = fLastUsedTriggerMask;
      do {
    i = (i+1)%MAX_NUM_EVENT_TRIGGERS;
    mask &gt;&gt;= 1;
    if (mask == 0) mask = 0x80000000;
    if ((fTriggersAwaitingHandling&amp;mask) != 0) {
      fTriggersAwaitingHandling &amp;=~ mask;
      if (fTriggeredEventHandlers[i] != NULL) {
        (*fTriggeredEventHandlers[i])(fTriggeredEventClientDatas[i]);
      }
      fLastUsedTriggerMask = mask;
      fLastUsedTriggerNum = i;
      break;
    }
      } while (i != fLastUsedTriggerNum);
    }
  }
  // Also handle any delayed event that may have come due.
  fDelayQueue.handleAlarm();
}<br></div></div>

<p>This function is a bit long, but is clearly divided into the following sections:</p>
<ol>
<li><p>According to the timer task list, the point in time from the current time
needed to perform the task as well as the recent passing of the maximum
delay time, calculate <code>select()</code> the maximum amount of time to be able to wait.</p>
</li>
<li><p>Execution <code>select()</code> latency on the socket.</p>
</li>
<li><p><code>select()</code> When a timeout or an I/O event on a socket arrives, the I/O event
handler for the socket where the I/O event occurred is first executed. This
function executes at most one I/O handler on the socket at a time.</p>
</li>
<li><p>Execute a user event handler. Also perform at most one at a time.</p>
</li>
<li><p>The timer task is executed, and the same one is executed at a time.</p>
</li>
</ol>
<p>The basics of live555 are basically that.</p>
<p><a href="https://www.wolfcstech.com/about/donate.html" target="_blank">Reward</a></p>
<p>Done.</p>
<h2 id="live555-source-code-analysis-series"><a name="live555-source-code-analysis-series" class="anchor-navigation-ex-anchor" href="#live555-source-code-analysis-series"><i class="fa fa-link" aria-hidden="true"></i></a>1.17. Live555 source code analysis series</h2>
<ol>
<li><a href="Live555%20-%20Live555%20source%20code%20analysis_introduction.html">Live555 Source code analysis: Introduction </a></li>
<li><a href="https://www.wolfcstech.com/2017/08/30/live555_src_analysis_infrasture/" target="_blank">live555 Source code analysis: Infrastructure </a></li>
<li><a href="Live555%20-%20Live555%20source%20code%20analysis_mediaserver.html">live555 Source code analysis: MediaSever </a></li>
<li><a href="Live555%20-%20Wireshark%20capture%20packet%20analysis%20RTSP_RTP_RTCP%20basic%20working%20process.html">Wireshark capture packet analysis RTSP/RTP/RTCP Basic working process </a></li>
<li><a href="Live555%20-%20Live555%20source%20code%20analysis_rtspserver.html">live555 Source code analysis: RTSPServer </a></li>
<li><a href="Live555%20-%20Live555%20source%20code%20analysis_describe%20processing.html">live555 Source code analysis: DESCRIBE processing </a></li>
<li><a href="Live555%20-%20Live555%20source%20code%20analysis_setup%20processing.html">live555 Source code analysis: SETUP processing </a></li>
<li><a href="Live555%20-%20Live555%20source%20code%20analysis_play%20processing.html">live555 Source code analysis :PLAY processing </a></li>
<li><a href="Live555%20-%20Live555%20source%20code%20analysis_RTSPServer%20component%20structure.html">live555 Source code analysis: RTSPServer component structure </a></li>
<li><a href="Live555%20-%20Live555%20source%20code%20analysis_servermediasession.html">live555 Source code analysis: </a></li>
<li><a href="Live555%20-%20Live555%20source%20code%20analysis_subsession%20SDP%20line%20generation.html">ServerMediaSession live555 Source code analysis: sub-session SDP line generation </a></li>
<li><a href="Live555%20-%20Live555%20source%20code%20analysis_Subsession%20SETUP.html">live555 Source code analysis: sub-session SETUP </a></li>
<li><a href="Live555%20-%20Live555%20source%20code%20analysis_play%20start.html">live555 Source code analysis: play start</a></li>
</ol>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="Live555 - Live555 source code analysis_introduction.html" class="navigation navigation-prev " aria-label="Previous page: Live555 - Live555 source code analysis_introduction">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="Live555 - Live555 source code analysis_mediaserver.html" class="navigation navigation-next " aria-label="Next page: Live555 - Live555 source code analysis_mediaserver">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Live555 - Live555 source code analysis_infrastructure","level":"1.10.2","depth":2,"next":{"title":"Live555 - Live555 source code analysis_mediaserver","level":"1.10.3","depth":2,"path":"Live555 - Live555 source code analysis_mediaserver.md","ref":"Live555 - Live555 source code analysis_mediaserver.md","articles":[]},"previous":{"title":"Live555 - Live555 source code analysis_introduction","level":"1.10.1","depth":2,"path":"Live555 - Live555 source code analysis_introduction.md","ref":"Live555 - Live555 source code analysis_introduction.md","articles":[]},"dir":"ltr"},"config":{"plugins":["include-html","fancybox","anchor-navigation-ex-toc","ace","-lunr","-search","search-plus","hide-published-with","splitter","expandable-chapters-interactive","wide-page"],"root":"./docs","styles":{"website":"styles/website.css"},"pluginsConfig":{"fancybox":{"helpers":{"buttons":{}}},"ace":{},"splitter":{},"wide-page":{},"anchor-navigation-ex-toc":{"showLevel":true,"associatedWithSummary":true,"mode":"float","printLog":false,"multipleH1":true,"float":{"showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""},"pageTop":{"showLevelIcon":false,"level1Icon":"","level2Icon":"","level3Icon":""}},"hide-published-with":{},"include-html":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"expandable-chapters-interactive":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"expandable-chapters":{},"search-plus":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"gitbook":"*"},"file":{"path":"Live555 - Live555 source code analysis_infrastructure.md","mtime":"2019-03-05T10:46:39.883Z","type":"markdown"},"gitbook":{"version":"3.3.6","time":"2023-12-10T09:35:29.798Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.mousewheel.pack.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.fancybox.pack.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/jquery.fancybox-buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fancybox/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-ace/ace/ace.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-ace/ace.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search-plus/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-hide-published-with/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-interactive/expandable-chapters.js"></script>
        
    
        
        <script src="gitbook/@gitbook-ng/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

